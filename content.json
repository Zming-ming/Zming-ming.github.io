{"pages":[{"title":"404","text":"","path":"404/index.html","date":"09-06","excerpt":""},{"title":"关于我","text":"","path":"about/index.html","date":"09-06","excerpt":""},{"title":"images","text":"","path":"images/index.html","date":"09-06","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"09-06","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"09-06","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"09-06","excerpt":""}],"posts":[{"title":"MySQL 函数","text":"MySQL 字符串函数ASCII(s)返回字符串 s 的第一个字符的 ASCII 码。返回 CustomerName 字段第一个字母的 ASCII 码： SELECT ASCII(CustomerName) AS NumCodeOfFirstCharFROM Customers; CHAR_LENGTH(s)返回字符串 s 的字符数返回字符串 RUNOOB 的字符数： SELECT CHAR_LENGTH(“RUNOOB”) AS LengthOfString; CHARACTER_LENGTH(s)返回字符串 s 的字符数返回字符串 RUNOOB 的字符数： SELECT CHARACTER_LENGTH(“RUNOOB”) AS LengthOfString; CONCAT(s1,s2…sn)字符串 s1,s2 等多个字符串合并为一个字符串合并多个字符串 SELECT CONCAT(“SQL “, “Runoob “, “Gooogle “, “Facebook”) AS ConcatenatedString; CONCAT_WS(x, s1,s2…sn)同 CONCAT(s1,s2,…) 函数，但是每个字符串直接要加上 x，x 可以是分隔符合并多个字符串，并添加分隔符： SELECT CONCAT_WS(“-“, “SQL”, “Tutorial”, “is”, “fun!”)AS ConcatenatedString; FIELD(s,s1,s2…)返回第一个字符串 s 在字符串列表(s1,s2…)中的位置返回字符串 c 在列表值中的位置： SELECT FIELD(“c”, “a”, “b”, “c”, “d”, “e”); FIND_IN_SET(s1,s2)返回在字符串s2中与s1匹配的字符串的位置返回字符串 c 在指定字符串中的位置： SELECT FIND_IN_SET(“c”, “a,b,c,d,e”); FORMAT(x,n)函数可以将数字 x 进行格式化 “#,###.##”, 将 x 保留到小数点后 n 位，最后一位四舍五入。格式化数字 “#,###.##” 形式： SELECT FORMAT(250500.5634, 2); – 输出 250,500.56 INSERT(s1,x,len,s2)字符串 s2 替换 s1 的 x 位置开始长度为 len 的字符串从字符串第一个位置开始的 6 个字符替换为 runoob： SELECT INSERT(“google.com”, 1, 6, “runnob”); – 输出：runoob.com LOCATE(s1,s)从字符串 s 中获取 s1 的开始位置获取 b 在字符串 abc 中的位置： SELECT LOCATE(‘st’,’myteststring’); – 5 LCASE(s)将字符串 s 的所有字母变成小写字母字符串 RUNOOB 转换为小写： SELECT LOWER(‘RUNOOB’) – runoob LEFT(s,n)返回字符串 s 的前 n 个字符返回字符串 runoob 中的前两个字符： SELECT LEFT(‘runoob’,2) – ru LEFT(s,n)返回字符串 s 的前 n 个字符返回字符串 abcde 的前两个字符： SELECT LEFT(‘abcde’,2) – ab LOCATE(s1,s)从字符串 s 中获取 s1 的开始位置返回字符串 abc 中 b 的位置： SELECT LOCATE(‘b’, ‘abc’) – 2 LOWER(s)将字符串 s 的所有字母变成小写字母字符串 RUNOOB 转换为小写： SELECT LOWER(‘RUNOOB’) – runoob LPAD(s1,len,s2)在字符串 s1 的开始处填充字符串 s2，使字符串长度达到 len将字符串 xx 填充到 abc 字符串的开始处： SELECT LPAD(‘abc’,5,’xx’) – xxabc LTRIM(s)去掉字符串 s 开始处的空格去掉字符串 RUNOOB开始处的空格： SELECT LTRIM(“ RUNOOB”) AS LeftTrimmedString;– RUNOOB MID(s,n,len)从字符串 s 的 start 位置截取长度为 length 的子字符串，同 SUBSTRING(s,n,len)从字符串 RUNOOB 中的第 2 个位置截取 3个 字符： SELECT MID(“RUNOOB”, 2, 3) AS ExtractString; – UNO POSITION(s1 IN s)从字符串 s 中获取 s1 的开始位置返回字符串 abc 中 b 的位置： SELECT POSITION(‘b’ in ‘abc’) – 2 REPEAT(s,n)将字符串 s 重复 n 次将字符串 runoob 重复三次： SELECT REPEAT(‘runoob’,3) – runoobrunoobrunoob REPLACE(s,s1,s2)将字符串 s2 替代字符串 s 中的字符串 s1将字符串 abc 中的字符 a 替换为字符 x： SELECT REPLACE(‘abc’,’a’,’x’) –xbc REVERSE(s)将字符串s的顺序反过来将字符串 abc 的顺序反过来： SELECT REVERSE(‘abc’) – cba RIGHT(s,n)返回字符串 s 的后 n 个字符返回字符串 runoob 的后两个字符： SELECT RIGHT(‘runoob’,2) – ob RPAD(s1,len,s2)在字符串 s1 的结尾处添加字符串 s1，使字符串的长度达到 len将字符串 xx 填充到 abc 字符串的结尾处： SELECT RPAD(‘abc’,5,’xx’) – abcxx RTRIM(s)去掉字符串 s 结尾处的空格去掉字符串 RUNOOB 的末尾空格： SELECT RTRIM(“RUNOOB “) AS RightTrimmedString; – RUNOOB SPACE(n)返回 n 个空格返回 10 个空格： SELECT SPACE(10); STRCMP(s1,s2)比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1&gt;s2 返回 1，如果 s1&lt;s2 返回 -1比较字符串： SELECT STRCMP(“runoob”, “runoob”); – 0 SUBSTR(s, start, length)从字符串 s 的 start 位置截取长度为 length 的子字符串从字符串 RUNOOB 中的第 2 个位置截取 3个 字符： SELECT SUBSTR(“RUNOOB”, 2, 3) AS ExtractString; – UNO SUBSTRING(s, start, length)从字符串 s 的 start 位置截取长度为 length 的子字符串从字符串 RUNOOB 中的第 2 个位置截取 3个 字符： SELECT SUBSTRING(“RUNOOB”, 2, 3) AS ExtractString; – UNO SUBSTRING_INDEX(s, delimiter, number)返回从字符串 s 的第 number 个出现的分隔符 delimiter 之后的子串。如果 number 是正数，返回第 number 个字符左边的字符串。如果 number 是负数，返回第(number 的绝对值(从右边数))个字符右边的字符串。 SELECT SUBSTRING_INDEX(‘ab’,’‘,1) – aSELECT SUBSTRING_INDEX(‘ab’,’‘,-1) – bSELECT SUBSTRING_INDEX(SUBSTRING_INDEX(‘abcde’,’‘,3),’‘,-1) – c TRIM(s)去掉字符串 s 开始和结尾处的空格去掉字符串 RUNOOB 的首尾空格： SELECT TRIM(‘ RUNOOB ‘) AS TrimmedString; UCASE(s)将字符串转换为大写将字符串 runoob 转换为大写： SELECT UCASE(“runoob”); – RUNOOB UPPER(s)将字符串转换为大写将字符串 runoob 转换为大写： SELECT UPPER(“runoob”); – RUNOOB MySQL 数字函数ABS(x)返回 x 的绝对值 返回 -1 的绝对值： SELECT ABS(-1) – 返回1 ACOS(x)求 x 的反余弦值(参数是弧度) SELECT ACOS(0.25); ASIN(x)求反正弦值(参数是弧度) SELECT ASIN(0.25); ATAN(x)求反正切值(参数是弧度) SELECT ATAN(2.5); ATAN2(n, m)求反正切值(参数是弧度) SELECT ATAN2(-0.8, 2); AVG(expression)返回一个表达式的平均值，expression 是一个字段返回 Products 表中Price 字段的平均值： SELECT AVG(Price) AS AveragePrice FROM Products; CEIL(x)返回大于或等于 x 的最小整数 SELECT CEIL(1.5) – 返回2 CEILING(x)返回大于或等于 x 的最小整数 SELECT CEIL(1.5) – 返回2 COS(x)求余弦值(参数是弧度) SELECT COS(2); COT(x)求余切值(参数是弧度) SELECT COT(6); COUNT(expression)返回查询的记录总数，expression 参数是一个字段或者 * 号返回 Products 表中 products 字段总共有多少条记录： SELECT COUNT(ProductID) AS NumberOfProducts FROM Products; DEGREES(x)将弧度转换为角度 SELECT DEGREES(3.1415926535898) – 180 n DIV m整除，n 为被除数，m 为除数计算 10 除于 5： SELECT 10 DIV 5; – 2 EXP(x)返回 e 的 x 次方 计算 e 的三次方： SELECT EXP(3) – 20.085536923188 FLOOR(x)返回小于或等于 x 的最大整数 小于或等于 1.5 的整数： SELECT FLOOR(1.5) – 返回1 GREATEST(expr1, expr2, expr3, …)返回列表中的最大值返回以下数字列表中的最大值： SELECT GREATEST(3, 12, 34, 8, 25); – 34 返回以下字符串列表中的最大值： SELECT GREATEST(“Google”, “Runoob”, “Apple”); – Runoob LEAST(expr1, expr2, expr3, …)返回列表中的最小值返回以下数字列表中的最小值： SELECT LEAST(3, 12, 34, 8, 25); – 3 返回以下字符串列表中的最小值： SELECT LEAST(“Google”, “Runoob”, “Apple”); – Apple LN返回数字的自然对数返回 2 的自然对数： SELECT LN(2); – 0.6931471805599453 LOG(x)返回自然对数(以 e 为底的对数) SELECT LOG(20.085536923188) – 3 LOG10(x)返回以 10 为底的对数 SELECT LOG10(100) – 2 LOG2(x)返回以 2 为底的对数返回以 2 为底 6 的对数： SELECT LOG2(6); – 2.584962500721156 MAX(expression)返回字段 expression 中的最大值返回数据表 Products 中字段 Price 的最大值： SELECT MAX(Price) AS LargestPrice FROM Products; MIN(expression)返回字段 expression 中的最小值返回数据表 Products 中字段 Price 的最小值： SELECT MIN(Price) AS LargestPrice FROM Products; MOD(x,y)返回 x 除以 y 以后的余数 5 除于 2 的余数： SELECT MOD(5,2) – 1 PI()返回圆周率(3.141593） SELECT PI() –3.141593 POW(x,y)返回 x 的 y 次方 2 的 3 次方： SELECT POW(2,3) – 8 POWER(x,y)返回 x 的 y 次方 2 的 3 次方： SELECT POWER(2,3) – 8 RADIANS(x)将角度转换为弧度 180 度转换为弧度： SELECT RADIANS(180) – 3.1415926535898 RAND()返回 0 到 1 的随机数 SELECT RAND() –0.93099315644334 ROUND(x)返回离 x 最近的整数 SELECT ROUND(1.23456) –1 SIGN(x)返回 x 的符号，x 是负数、0、正数分别返回 -1、0 和 1 SELECT SIGN(-10) – (-1) SIN(x)求正弦值(参数是弧度) SELECT SIN(RADIANS(30)) – 0.5 SQRT(x)返回x的平方根 25 的平方根： SELECT SQRT(25) – 5 SUM(expression)返回指定字段的总和计算 OrderDetails 表中字段 Quantity 的总和： SELECT SUM(Quantity) AS TotalItemsOrdered FROM OrderDetails; TAN(x)求正切值(参数是弧度) SELECT TAN(1.75); – -5.52037992250933 TRUNCATE(x,y)返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别是不会进行四舍五入） SELECT TRUNCATE(1.23456,3) – 1.234 MySQL 日期函数ADDDATE(d,n)计算其实日期 d 加上 n 天的日期 SELECT ADDDATE(“2017-06-15”, INTERVAL 10 DAY);-&gt;2017-06-25 ADDTIME(t,n)时间 t 加上 n 秒的时间 SELECT ADDTIME(‘2011-11-11 11:11:11’, 5)-&gt;2011-11-11 11:11:16 (秒) CURDATE()返回当前日期 SELECT CURDATE();-&gt; 2018-09-19 CURRENT_DATE()返回当前日期 SELECT CURRENT_DATE();-&gt; 2018-09-19 CURRENT_TIME返回当前时间 SELECT CURRENT_TIME();-&gt; 19:59:02 CURRENT_TIMESTAMP()返回当前日期和时间 SELECT CURRENT_TIMESTAMP()-&gt; 2018-09-19 20:57:43 CURTIME()返回当前时间 SELECT CURTIME();-&gt; 19:59:02 DATE()从日期或日期时间表达式中提取日期值 SELECT DATE(“2017-06-15”);-&gt; 2017-06-15 DATEDIFF(d1,d2)计算日期 d1-&gt;d2 之间相隔的天数 SELECT DATEDIFF(‘2001-01-01’,’2001-02-02’)-&gt; -32 DATE_ADD(d，INTERVAL expr type)计算起始日期 d 加上一个时间段后的日期 SELECT ADDDATE(‘2011-11-11 11:11:11’,1)-&gt; 2011-11-12 11:11:11 (默认是天) SELECT ADDDATE(‘2011-11-11 11:11:11’, INTERVAL 5 MINUTE)-&gt; 2011-11-11 11:16:11 (TYPE的取值与上面那个列出来的函数类似) DATE_FORMAT(d,f)按表达式 f的要求显示日期 d SELECT DATE_FORMAT(‘2011-11-11 11:11:11’,’%Y-%m-%d %r’)-&gt; 2011-11-11 11:11:11 AM DATE_SUB(date,INTERVAL expr type)函数从日期减去指定的时间间隔。Orders 表中 OrderDate 字段减去 2 天： SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 2 DAY) AS OrderPayDateFROM Orders DAY(d)返回日期值 d 的日期部分 SELECT DAY(“2017-06-15”);-&gt; 15 DAYNAME(d)返回日期 d 是星期几，如 Monday,Tuesday SELECT DAYNAME(‘2011-11-11 11:11:11’)-&gt;Friday DAYOFMONTH(d)计算日期 d 是本月的第几天 SELECT DAYOFMONTH(‘2011-11-11 11:11:11’)-&gt;11 DAYOFWEEK(d)日期 d 今天是星期几，1 星期日，2 星期一，以此类推 SELECT DAYOFWEEK(‘2011-11-11 11:11:11’)-&gt;6 DAYOFYEAR(d)计算日期 d 是本年的第几天 SELECT DAYOFYEAR(‘2011-11-11 11:11:11’)-&gt;315 EXTRACT(type FROM d)从日期 d 中获取指定的值，type 指定返回的值。type可取值为：·MICROSECOND·SECOND·MINUTE·HOUR·DAY·WEEK·MONTH·QUARTER·YEAR·SECOND_MICROSECOND·MINUTE_MICROSECOND·MINUTE_SECOND·HOUR_MICROSECOND·HOUR_SECOND·HOUR_MINUTE·DAY_MICROSECOND·DAY_SECOND·DAY_MINUTE·DAY_HOUR·YEAR_MONTH SELECT EXTRACT(MINUTE FROM ‘2011-11-11 11:11:11’)-&gt; 11 FROM_DAYS(n)计算从 0000 年 1 月 1 日开始 n 天后的日期 SELECT FROM_DAYS(1111)-&gt; 0003-01-16 HOUR(t)返回 t 中的小时值 SELECT HOUR(‘1:2:3’)-&gt; 1 LAST_DAY(d)返回给给定日期的那一月份的最后一天 SELECT LAST_DAY(“2017-06-20”);-&gt; 2017-06-30 LOCALTIME()返回当前日期和时间 SELECT LOCALTIME()-&gt; 2018-09-19 20:57:43 LOCALTIMESTAMP()返回当前日期和时间 SELECT LOCALTIMESTAMP()-&gt; 2018-09-19 20:57:43 MAKEDATE(year, day-of-year)基于给定参数年份 year 和所在年中的天数序号 day-of-year 返回一个日期 SELECT MAKEDATE(2017, 3);-&gt; 2017-01-03 MAKETIME(hour, minute, second)组合时间，参数分别为小时、分钟、秒 SELECT MAKETIME(11, 35, 4);-&gt; 11:35:04 MICROSECOND(date)返回日期参数所对应的毫秒数 SELECT MICROSECOND(“2017-06-20 09:34:00.000023”);-&gt; 23 MINUTE(t)返回 t 中的分钟值 SELECT MINUTE(‘1:2:3’)-&gt; 2 MONTHNAME(d)返回日期当中的月份名称，如 Janyary SELECT MONTHNAME(‘2011-11-11 11:11:11’)-&gt; November MONTH(d)返回日期d中的月份值，1 到 12 SELECT MONTH(‘2011-11-11 11:11:11’)-&gt;11 NOW()返回当前日期和时间 SELECT NOW()-&gt; 2018-09-19 20:57:43 PERIOD_ADD(period, number)为 年-月 组合日期添加一个时段 SELECT PERIOD_ADD(201703, 5);-&gt; 201708 PERIOD_DIFF(period1, period2)返回两个时段之间的月份差值 SELECT PERIOD_DIFF(201710, 201703);-&gt; 7 QUARTER(d)返回日期d是第几季节，返回 1 到 4 SELECT QUARTER(‘2011-11-11 11:11:11’)-&gt; 4 SECOND(t)返回 t 中的秒钟值 SELECT SECOND(‘1:2:3’)-&gt; 3 SEC_TO_TIME(s)将以秒为单位的时间 s 转换为时分秒的格式 SELECT SEC_TO_TIME(4320)-&gt; 01:12:00 STR_TO_DATE(string, format_mask)将字符串转变为日期 SELECT STR_TO_DATE(“August 10 2017”, “%M %d %Y”);-&gt; 2017-08-10 SUBDATE(d,n)日期 d 减去 n 天后的日期 SELECT SUBDATE(‘2011-11-11 11:11:11’, 1)-&gt;2011-11-10 11:11:11 (默认是天) SUBTIME(t,n)时间 t 减去 n 秒的时间 SELECT SUBTIME(‘2011-11-11 11:11:11’, 5)-&gt;2011-11-11 11:11:06 (秒) SYSDATE()返回当前日期和时间 SELECT SYSDATE()-&gt; 2018-09-19 20:57:43 TIME(expression)提取传入表达式的时间部分 SELECT TIME(“19:30:10”);-&gt; 19:30:10 TIME_FORMAT(t,f)按表达式 f 的要求显示时间 t SELECT TIME_FORMAT(‘11:11:11’,’%r’)11:11:11 AM TIME_TO_SEC(t)将时间 t 转换为秒 SELECT TIME_TO_SEC(‘1:12:00’)-&gt; 4320 TIMEDIFF(time1, time2)计算时间差值 SELECT TIMEDIFF(“13:10:11”, “13:10:10”);-&gt; 00:00:01 TIMESTAMP(expression, interval)单个参数时，函数返回日期或日期时间表达式；有2个参数时，将参数加和 SELECT TIMESTAMP(“2017-07-23”, “13:10:11”);-&gt; 2017-07-23 13:10:11 TO_DAYS(d)计算日期 d 距离 0000 年 1 月 1 日的天数 SELECT TO_DAYS(‘0001-01-01 01:01:01’)-&gt; 366 WEEK(d)计算日期 d 是本年的第几个星期，范围是 0 到 53 SELECT WEEK(‘2011-11-11 11:11:11’)-&gt; 45 WEEKDAY(d)日期 d 是星期几，0 表示星期一，1 表示星期二 SELECT WEEKDAY(“2017-06-15”);-&gt; 3 WEEKOFYEAR(d)计算日期 d 是本年的第几个星期，范围是 0 到 53 SELECT WEEKOFYEAR(‘2011-11-11 11:11:11’)-&gt; 45 YEAR(d)返回年份 SELECT YEAR(“2017-06-15”);-&gt; 2017 YEARWEEK(date, mode)返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推 SELECT YEARWEEK(“2017-06-15”);-&gt; 201724 MySQL 高级函数BIN(x)返回 x 的二进制编码15 的 2 进制编码: SELECT BIN(15); – 1111 BINARY(s)将字符串 s 转换为二进制字符串 SELECT BINARY “RUNOOB”;-&gt; RUNOOB CASE expressionWHEN condition1 THEN result1 WHEN condition2 THEN result2 。。。 WHEN conditionN THEN resultN ELSE resultEND CASE 表示函数开始，END 表示函数结束。如果 condition1 成立，则返回 result1, 如果 condition2 成立，则返回 result2，当全部不成立则返回 result，而当有一个成立之后，后面的就不执行了。 SELECT CASE WHEN 1 &gt; 0 THEN ‘1 &gt; 0’ WHEN 2 &gt; 0 THEN ‘2 &gt; 0’ ELSE ‘3 &gt; 0’ END-&gt;1 &gt; 0 CAST(x AS type)转换数据类型字符串日期转换为日期： SELECT CAST(“2017-08-29” AS DATE);-&gt; 2017-08-29 COALESCE(expr1, expr2, …., expr_n)返回参数中的第一个非空表达式（从左向右） SELECT COALESCE(NULL, NULL, NULL, ‘runoob.com’, NULL, ‘google.com’);-&gt; runoob.com CONNECTION_ID()返回服务器的连接数 SELECT CONNECTION_ID();-&gt; 4292835 CONV(x,f1,f2)返回 f1 进制数变成 f2 进制数 SELECT CONV(15, 10, 2);-&gt; 1111 CONVERT(s USING cs)函数将字符串 s 的字符集变成 cs SELECT CHARSET(‘ABC’)-&gt;utf-8 SELECT CHARSET(CONVERT(‘ABC’ USING gbk))-&gt;gbk CURRENT_USER()返回当前用户 SELECT CURRENT_USER();-&gt; guest@% DATABASE()返回当前数据库名 SELECT DATABASE();-&gt; runoob IF(expr,v1,v2)如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。 SELECT IF(1 &gt; 0,’正确’,’错误’)-&gt;正确 IFNULL(v1,v2)如果 v1 的值不为 NULL，则返回 v1，否则返回 v2。 SELECT IFNULL(null,’Hello Word’)-&gt;Hello Word ISNULL(expression)判断表达式是否为 NULL SELECT ISNULL(NULL);-&gt;1 LAST_INSERT_ID()返回最近生成的 AUTO_INCREMENT 值 SELECT LAST_INSERT_ID();-&gt;6 NULLIF(expr1, expr2)比较两个字符串，如果字符串 expr1 与 expr2 相等 返回 NULL，否则返回 expr1 SELECT NULLIF(25, 25);-&gt; SESSION_USER()返回当前用户 SELECT SESSION_USER();-&gt; guest@% SYSTEM_USER()返回当前用户 SELECT SYSTEM_USER();-&gt; guest@% USER()返回当前用户 SELECT USER();-&gt; guest@% VERSION()返回数据库的版本号 SELECT VERSION()-&gt; 5.6.34","path":"2018/11/23/MySQL-函数/","date":"11-23","excerpt":""},{"title":"Linux 守护进程的启动方法","text":"一、问题的由来Web应用写好后，下一件事就是启动，让它一直在后台运行。这并不容易。举例来说，下面是一个最简单的Node应用server.js，只有6行。123456var http = require(&apos;http&apos;);http.createServer(function(req, res) &#123; res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); res.end(&apos;Hello World&apos;);&#125;).listen(5000); 你在命令行下启动它。1$ node server.js 看上去一切正常，所有人都能快乐地访问 5000 端口了。但是，一旦你退出命令行窗口，这个应用就一起退出了，无法访问了。怎么才能让它变成系统的守护进程（daemon），成为一种服务（service），一直在那里运行呢？二、前台任务与后台任务上面这样启动的脚本，称为”前台任务”（foreground job）。它会独占命令行窗口，只有运行完了或者手动中止，才能执行其他命令。变成守护进程的第一步，就是把它改成”后台任务”（background job）。1$ node server.js &amp; 只要在命令的尾部加上符号&amp;，启动的进程就会成为”后台任务”。如果要让正在运行的”前台任务”变为”后台任务”，可以先按ctrl + z，然后执行bg命令（让最近一个暂停的”后台任务”继续执行）。“后台任务”有两个特点。12继承当前 session （对话）的标准输出（stdout）和标准错误（stderr）。因此，后台任务的所有输出依然会同步地在命令行下显示。不再继承当前 session 的标准输入（stdin）。你无法向这个任务输入指令了。如果它试图读取标准输入，就会暂停执行（halt）。 可以看到，”后台任务”与”前台任务”的本质区别只有一个：是否继承标准输入。所以，执行后台任务的同时，用户还可以输入其他命令。三、SIGHUP信号变为”后台任务”后，一个进程是否就成为了守护进程呢？或者说，用户退出 session 以后，”后台任务”是否还会继续执行？Linux系统是这样设计的。1234用户准备退出 session系统向该 session 发出SIGHUP信号session 将SIGHUP信号发给所有子进程子进程收到SIGHUP信号后，自动退出 上面的流程解释了，为什么”前台任务”会随着 session 的退出而退出：因为它收到了SIGHUP信号。那么，”后台任务”是否也会收到SIGHUP信号？这由 Shell 的huponexit参数决定的。1$ shopt | grep huponexit 执行上面的命令，就会看到huponexit参数的值。大多数Linux系统，这个参数默认关闭（off）。因此，session 退出的时候，不会把SIGHUP信号发给”后台任务”。所以，一般来说，”后台任务”不会随着 session 一起退出四、disown 命令通过”后台任务”启动”守护进程”并不保险，因为有的系统的huponexit参数可能是打开的（on）。更保险的方法是使用disown命令。它可以将指定任务从”后台任务”列表（jobs命令的返回结果）之中移除。一个”后台任务”只要不在这个列表之中，session 就肯定不会向它发出SIGHUP信号。12$ node server.js &amp;$ disown 执行上面的命令以后，server.js进程就被移出了”后台任务”列表。你可以执行jobs命令验证，输出结果里面，不会有这个进程。disown的用法如下。123456789101112131415# 移出最近一个正在执行的后台任务$ disown# 移出所有正在执行的后台任务$ disown -r# 移出所有后台任务$ disown -a# 不移出后台任务，但是让它们不会收到SIGHUP信号$ disown -h# 根据jobId，移出指定的后台任务$ disown %2$ disown -h %2 五、标准 I/O使用disown命令之后，还有一个问题。那就是，退出 session 以后，如果后台进程与标准I/O有交互，它还是会挂掉。还是以上面的脚本为例，现在加入一行。1234567var http = require(&apos;http&apos;);http.createServer(function(req, res) &#123; console.log(&apos;server starts...&apos;); // 加入此行 res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); res.end(&apos;Hello World&apos;);&#125;).listen(5000); 启动上面的脚本，然后再执行disown命令。12$ node server.js &amp;$ disown 接着，你退出 session，访问5000端口，就会发现连不上。这是因为”后台任务”的标准 I/O 继承自当前 session，disown命令并没有改变这一点。一旦”后台任务”读写标准 I/O，就会发现它已经不存在了，所以就报错终止执行。为了解决这个问题，需要对”后台任务”的标准 I/O 进行重定向。12$ node server.js &gt; stdout.txt 2&gt; stderr.txt &lt; /dev/null &amp;$ disown 上面这样执行，基本上就没有问题了六、nohup 命令还有比disown更方便的命令，就是nohup。1$ nohup node server.js &amp; nohup命令对server.js进程做了三件事。123阻止SIGHUP信号发到这个进程。关闭标准输入。该进程不再能够接收任何输入，即使运行在前台。重定向标准输出和标准错误到文件nohup.out。 也就是说，nohup命令实际上将子进程与它所在的 session 分离了。 注意，nohup命令不会自动把进程变为”后台任务”，所以必须加上&amp;符号。 七、Screen 命令与 Tmux 命令另一种思路是使用 terminal multiplexer （终端复用器：在同一个终端里面，管理多个session），典型的就是 Screen 命令和 Tmux 命令。它们可以在当前 session 里面，新建另一个 session。这样的话，当前 session 一旦结束，不影响其他 session。而且，以后重新登录，还可以再连上早先新建的 session。Screen 的用法如下。123# 新建一个 session$ screen$ node server.js 然后，按下ctrl + A和ctrl + D，回到原来的 session，从那里退出登录。下次登录时，再切回去。1$ screen -r 如果新建多个后台 session，就需要为它们指定名字。12345678$ screen -S name# 切回指定 session$ screen -r name$ screen -r pid_number# 列出所有 session$ screen -ls 如果要停掉某个 session，可以先切回它，然后按下ctrl + c和ctrl + d。Tmux 比 Screen 功能更多、更强大，它的基本用法如下。12345$ tmux$ node server.js# 返回原来的session$ tmux detach 除了tmux detach，另一种方法是按下Ctrl + B和d，也可以回到原来的 session。12# 下次登录时，返回后台正在运行服务session$ tmux attach 如果新建多个 session，就需要为每个 session 指定名字。1234567891011121314# 新建 session$ tmux new -s session_name# 切换到指定 session$ tmux attach -t session_name# 列出所有 session$ tmux list-sessions# 退出当前 session，返回前一个 session $ tmux detach# 杀死指定 session$ tmux kill-session -t session-name 八、Node 工具对于 Node 应用来说，可以不用上面的方法，有一些专门用来启动的工具：forever，nodemon 和 pm2。forever 的功能很简单，就是保证进程退出时，应用会自动重启。1234567891011121314151617181920# 作为前台任务启动$ forever server.js# 作为服务进程启动 $ forever start app.js# 停止服务进程$ forever stop Id# 重启服务进程$ forever restart Id# 监视当前目录的文件变动，一有变动就重启$ forever -w server.js# -m 参数指定最多重启次数$ forever -m 5 server.js # 列出所有进程$ forever list nodemon一般只在开发时使用，它最大的长处在于 watch 功能，一旦文件发生变化，就自动重启进程。12345# 默认监视当前目录的文件变化$ nodemon server.js＃ 监视指定文件的变化 $ nodemon --watch app --watch libs server.js pm2 的功能最强大，除了重启进程以外，还能实时收集日志和监控。123456789101112131415161718192021222324252627282930313233343536# 启动应用$ pm2 start app.js# 指定同时起多少个进程（由CPU核心数决定），组成一个集群$ pm2 start app.js -i max# 列出所有任务$ pm2 list# 停止指定任务$ pm2 stop 0＃ 重启指定任务$ pm2 restart 0# 删除指定任务$ pm2 delete 0# 保存当前的所有任务，以后可以恢复$ pm2 save# 列出每个进程的统计数据$ pm2 monit# 查看所有日志$ pm2 logs# 导出数据$ pm2 dump# 重启所有进程$ pm2 kill$ pm2 resurect# 启动web界面 http://localhost:9615$ pm2 web","path":"2018/11/02/Linux-守护进程的启动方法/","date":"11-02","excerpt":""},{"title":"常用 Git 命令清单","text":"一、新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 六、标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 八、远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 十、其他12# 生成一个可供发布的压缩包$ git archive","path":"2018/11/02/常用-Git-命令清单/","date":"11-02","excerpt":""},{"title":"基于个推（GeTui）官方SDK集成 Laravel 5.* ","text":"Laravel GeTui基于 个推官方SDK for Laravel.github:https://github.com/ShaoZeMing/laravel-getuiInstalling1$ composer require shaozeming/laravel-getui -v Laravel12345678// config/app.php &apos;providers&apos; =&gt; [ //... ShaoZeMing\\GeTui\\GeTuiServiceProvider::class, //This is default in laravel 5.5 ],``` #### And publish the config file: $ php artisan vendor:publish –provider=ShaoZeMing\\GeTui\\GeTuiServiceProvider 1###### if you want to use facade mode, you can register a facade name what you want to use, for example GeTui: // config/app.php &apos;aliases&apos; =&gt; [ &apos;GeTui&apos; =&gt; ShaoZeMing\\GeTui\\Facade\\GeTui::class, //This is default in laravel 5.5 ],123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354###### 将 `vendor/ShaoZeMing/laravel-getui/src/config/getui.php` 拷贝到项目根目录`/config`目录下，并将文件名改成`getui.php`。#### configuration// config/getui.php // APP_EVN 你的项目当前环境 测试、生产 &apos;app_env&apos; =&gt; env(&apos;APP_ENV&apos;) == &apos;production&apos; ? &apos;production&apos; : &apos;development&apos;, // The default default_client name which configured in `development` or `production` section //默认推送的客户端 &apos;default_client&apos; =&gt; &apos;client_1&apos;, &apos;development&apos; =&gt; [ &apos;client_1&apos; =&gt; [ &apos;gt_appid&apos; =&gt; &apos;WAqyXNcLpS8OLg4jBywS48&apos;, &apos;gt_appkey&apos; =&gt; &apos;FkxUuibQsT75FX5Tt5jteA&apos;, &apos;gt_appsecret&apos; =&gt; &apos;jWtd0iUzdmAvVPhKorrtW1&apos;, &apos;gt_mastersecret&apos; =&gt; &apos;4uCfJsfME99oaF5sT1ZjO&apos;, &apos;gt_domainurl&apos; =&gt; &apos;http://sdk.open.api.igexin.com/apiex.htm&apos;, ], &apos;client_2&apos; =&gt; [ &apos;gt_appid&apos; =&gt; &apos;SeldZ6X0Iq8hpj5rGvqAk8&apos;, &apos;gt_appkey&apos; =&gt; &apos;93MPU2THwl9okpeNf4lNI4&apos;, &apos;gt_appsecret&apos; =&gt; &apos;kzZuSXVMm29M7owpvId979&apos;, &apos;gt_mastersecret&apos; =&gt; &apos;0QCmCdVZSi8lcyMFXLB4e&apos;, &apos;gt_domainurl&apos; =&gt; &apos;http://sdk.open.api.igexin.com/apiex.htm&apos;, ], // other client_3 ], &apos;production&apos; =&gt; [ &apos;client_1&apos; =&gt; [ &apos;gt_appid&apos; =&gt; &apos;6V95sH0t3W6Du1MTiU3679&apos;, &apos;gt_appkey&apos; =&gt; &apos;n6q8NSAshP77ImKxdhuHV6&apos;, &apos;gt_appsecret&apos; =&gt; &apos;01hGwR1Jdl6vuwBcnvfyD3&apos;, &apos;gt_mastersecret&apos; =&gt; &apos;daw4hbkFj4Ah3kBlPFfIh2&apos;, &apos;gt_domainurl&apos; =&gt; &apos;http://sdk.open.api.igexin.com/apiex.htm&apos;, ], &apos;client_2&apos; =&gt; [ &apos;gt_appid&apos; =&gt; &apos;iB7DfaXV6bAf8zlJ0L59A8&apos;, &apos;gt_appkey&apos; =&gt; &apos;DKKp54s2knA2MaeGBXuF01&apos;, &apos;gt_appsecret&apos; =&gt; &apos;exTKWC0M1K6O2Bgig5RiC8&apos;, &apos;gt_mastersecret&apos; =&gt; &apos;0cojzBC7yB86mhOiOVHBuA&apos;, &apos;gt_domainurl&apos; =&gt; &apos;http://sdk.open.api.igexin.com/apiex.htm&apos;, ], // other client_3 ], ###### Usage###### Gateway instance: use GeTui;//针对单个或者多个用户推送GeTui::push($deviceId, $data,true) //Using default default_client 推送给默认的客户端GeTui::toClient(‘CLIENT NAME’)-&gt;push($deviceId, $data) // CLIENT NAME is key name of development or production configuration. //自定义发送的客户端 // 针对整个app所有人推送GeTui::pushToApp($data,true) ////Using default default_clientGeTui::toClient(‘CLIENT NAME’)-&gt;pushToApp($data) // GATEWAY NAME is key name of development or production configuration. 1###### Example: $deviceId = ‘b2e5b64931f06f617e363b74c8057cf6’;// 多个push对象device_id 用数组传入$deviceId = [ ‘ea34a4715b08b1b8d77aabf36c977cba’, ‘ea34a4715b08b1b8d77aabf36c977cba’, ];$data = [ ‘url’ =&gt; ‘http://test.4d4k.com/push&#39;, ‘type’ =&gt; ‘点击查看(^o^)/~’, ‘title’ =&gt; ‘23232323fdf’, ‘content’ =&gt; ‘今天天气真好’, ‘id’ =&gt; ‘3a92y3GR1neZ’, ‘merchant_name’ =&gt; ‘泽明科技’, ‘big_cat’ =&gt; ‘电视机’, ‘full_address’ =&gt; ‘北京市海淀区五道口清华大学’, ]; $res = \\GeTui::push($deviceId, $data,true); //Using default default_client print_r($res);```","path":"2018/10/30/基于个推（GeTui）官方SDK集成-Laravel-5/","date":"10-30","excerpt":""},{"title":"laravel5.5的定时任务详解","text":"一、创建定时任务的步骤1、根据文档，创建命令1首先进入到laravel/app/console 目录下，Console 目录包含应用所有自定义的 Artisan 命令，这些命令类可以使用 make:command 命令生成。该目录下还有 Console/Kernel 类，在这里可以注册自定义的 Artisan 命令以及定义调度任务。 例如我们创建一个定时任务，名称为Test:123//这里使用laravel给定的 php artisan来生成命令，此处的Test就是我们要生成的文件//这里的artisan代表的不仅仅是laravel自带的命令，他其实是laravel下的artisan目录，因为这个目录没有x，也就是可执行权限，所以不能使用 ./artisan 来执行，只能通过php来执行php artisan make:command Test 2、创建完之后，打开console目录下的commands目录，我们会发现里面已经有了一个文件大致的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpnamespace App\\Console\\Commands;use App\\Services\\CalculateDataService;use Illuminate\\Console\\Command;class Test extends Command&#123; //此处代表laravel自动生成的名称，下面执行的时候能用到 protected $signature = &apos;test:data&apos;; //此处代表的是描述，并没有什么用的 protected $description = &apos;test data&apos;; /** * 计算数据服务的 service 属性 *这里由于要用到我们的逻辑，所以提前定义一下，方便下面使用 * @var CalculateDataService */ protected $service; //这个是laravel自带的构造方法。初始状态下是空的。 //我这里由于要调用CalculateDataService 类的一个方法，所有就用依赖注入的方式引入了一下。 public function __construct(CalculateDataService $service) &#123; parent::__construct(); $this-&gt;service = $service; &#125; /** * Execute the console command. *这里就是我们执行操作的地方，里面是command要处理的业务。根据我们的需求， *调用类中的calculateData（）方法，该方法是我们自己的需求逻辑部分。 * @return mixed */ public function handle() &#123; try &#123; $this-&gt;service-&gt;calculateData(); &#125; catch (\\Exception $e) &#123; $this-&gt;error($e-&gt;getMessage()); &#125; // line()方法是command类中自带的方法，可以输出我们自定义的信息 $this-&gt;line(&apos;calculate Data Success!&apos;); &#125;&#125; 3、定时命令创建好之后，我们需要修改kernel.php文件kernel.php文件里面，主要是定义命令的调度时间，定义命令的执行先后顺序等。 这部分参考laravel官方文档:[http://laravelacademy.org/post/8484.html] (http://laravelacademy.org/post/8484.html)4、我的kernel.php文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php//此处省略了命名空间部分class Kernel extends ConsoleKernel&#123; /** * The Artisan commands provided by your application. *注：此处是引入我们新创建的类。由于我们此处是使用命令名来操作的，所以没用上这个类名。不过还是引入比较标准 * 可以使用 command 方法通过命令名或类来调度一个 Artisan 命令： * $schedule-&gt;command(&apos;emails:send --force&apos;)-&gt;daily(); * $schedule-&gt;command(EmailsCommand::class, [&apos;--force&apos;])-&gt;daily(); * * @var array */ protected $commands = [ Test::class, CalculateData::class, UpdateOffset::class, ]; /** * Define the application&apos;s command schedule. * 注： * 1、这个方法按照自己的需求，确定定时方法的执行顺序。通过after，before等关键词来控制 * 2、此处相当于规定同意的定时执行时间，如都在0:30分执行下面的几个定时任务 * @param \\Illuminate\\Console\\Scheduling\\Schedule $schedule * @return void */ protected function schedule(Schedule $schedule) &#123; // 每天凌晨 0.45 执行同步 aliyun 数据的任务，并发送邮件给 *** $schedule-&gt;command(&apos;iot:sync Flow&apos;) -&gt;after(function() &#123; //更新偏移量,after里面不能加参数 Artisan::call(&apos;Test:data&apos;); &#125;) -&gt;after(function () &#123; // 执行同步数据命令完成后 则执行计算数据任务 Artisan::call(&apos;calculate:data&apos;); &#125;); &#125; /** * Register the commands for the application. * //这个部分是laravel自动生成的，引入我们生成的命令文件 * @return void */ protected function commands() &#123; $this-&gt;load(__DIR__.&apos;/Commands&apos;); require base_path(&apos;routes/console.php&apos;); &#125;&#125; 关于具体的调度方法schedule（），大家可以去laravel文档看看，里面可以规定很多东西。我这边是使用的钩子函数。在同时要执行多个定时任务的时候，通过after，before等方法，可以让多个定时任务变得有序起来。 二、执行我们的定时 虽然laravel的定时任务一直都说的很强大，但本质上还是离不开服务器上的cron脚本。。 1、先查看服务器上的定时条目crontab -l2、新增或编辑cron 条目crontab -e","path":"2018/10/19/laravel5-5的定时任务详解/","date":"10-19","excerpt":""},{"title":"微信小程序的更新机制","text":"启动小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。 假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动；冷启动指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。更新机制小程序冷启动时如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。 如果需要马上应用最新版本，可以使用 wx.getUpdateManager API 进行处理。运行机制小程序没有重启的概念当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁当短时间内（5s）连续收到两次以上收到系统内存告警，会进行小程序的销毁更新小程序代码：根据微信提供的api，可以检测是否小程序有新版本代码如下// 检测是否可以调用getUpdateManager检查更新 if (!wx.canIUse(&quot;getUpdateManager&quot;)) return; let updateManager = wx.getUpdateManager(); // 获取全局唯一的版本更新管理器，用于管理小程序更新 updateManager.onCheckForUpdate(function (res) { // 监听向微信后台请求检查更新结果事件 console.log(&quot;是否有新版本：&quot;+res.hasUpdate); if(res.hasUpdate){ //如果有新版本 // 小程序有新版本，会主动触发下载操作 updateManager.onUpdateReady(function () { //当新版本下载完成，会进行回调 wx.showModal({ title: &apos;更新提示&apos;, content: &apos;新版本已经准备好，单击确定重启小程序&apos;, showCancel:false, success: function (res) { if (res.confirm) { // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启小程序 updateManager.applyUpdate(); } } }) }) // 小程序有新版本，会主动触发下载操作（无需开发者触发） updateManager.onUpdateFailed(function () { //当新版本下载失败，会进行回调 wx.showModal({ title: &apos;提示&apos;, content: &apos;检查到有新版本，但下载失败，请稍后尝试&apos;, showCancel: false, }) }) } });","path":"2018/10/17/微信小程序的更新机制/","date":"10-17","excerpt":""},{"title":"Markdown 语法","text":"1.标题代码 注：# 后面保持空格 12345678910# h1## h2### h3#### h4##### h5###### h6####### h7 // 错误代码######## h8 // 错误代码######### h9 // 错误代码########## h10 // 错误代码 演示h1h2h3h4h5h6####### h7 ######## h8 ######### h9 ########## h10 2.分级标题代码 注：= - 最少可以只写一个，兼容性一般 1234一级标题======================二级标题--------------------- 演示一级标题二级标题 3.TOC 注：根据标题生成目录，兼容性一般 代码1[TOC] 演示 4.引用代码1(单行式)1&gt; hello world! 演示 hello world! 代码2(多行式)123&gt; hello world!hello world!hello world! 或者 123&gt; hello world!&gt; hello world!&gt; hello world! 演示相同的结果 hello world! hello world! hello world! 代码3(多层嵌套)123&gt; aaaaaaaaa&gt;&gt; bbbbbbbbb&gt;&gt;&gt; cccccccccc 演示 aaaaaaaaa bbbbbbbbb cccccccccc 5、字体 加粗要加粗的文字左右分别用两个*号包起来 斜体要倾斜的文字左右分别用一个*号包起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~~号包起来示例：1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下：这是加粗的文字这是倾斜的文字` 这是斜体加粗的文字这是加删除线的文字 6、分割线三个或者三个以上的 - 或者 * 都可以。示例：1234-------******** 效果如下：可以看到，显示效果是一样的。 7、图片语法：123![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例：12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 效果如下： 8、超链接语法：12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下：简书百度 注：markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 12&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 9、列表无序列表语法：无序列表用 - + * 任何一种都可以1234- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容有序列表语法：数字加点12341.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 效果如下：1.列表内容2.列表内容3.列表内容 列表嵌套上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 10、表格语法：1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 *** 11、代码语法：单行代码：代码之间分别用一个反引号包起来123`代码内容```` ###### 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 (1234 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例：单行代码1`create database hero;` 代码块123456(```) function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;; &#125; fun();(```) 效果如下：单行代码create database hero; 代码块1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun();","path":"2018/09/21/Markdown-语法/","date":"09-21","excerpt":""},{"title":"Laravel Excel 实现 Excel/CSV 文件导入导出功能","text":"1、简介Laravel Excel 在 Laravel 5 中集成 PHPOffice 套件中的 PHPExcel，从而方便我们以优雅的、富有表现力的代码实现Excel/CSV文件的导入和导出。该项目的GitHub地址是https://github.com/Maatwebsite/Laravel-Excel。本文我们将在Laravel中使用Laravel Excel简单实现Excel文件的导入和导出。2、安装&amp;配置使用Composer安装依赖首先在Laravel项目根目录下使用Composer安装依赖：1composer require maatwebsite/excel 安装后的设置在config/app.php中注册服务提供者到providers数组：1Maatwebsite\\Excel\\ExcelServiceProvider::class, 同样在config/app.php中注册门面到aliases数组：1&apos;Excel&apos; =&gt; Maatwebsite\\Excel\\Facades\\Excel::class, 如果想要对Laravel Excel进行更多的自定义配置，执行如下Artisan命令：1php artisan vendor:publish 执行成功后会在config目录下生成一个配置文件excel.php。3、导出Excel文件为了演示Laravel Excel相关功能，我们为本测试创建一个干净的控制器ExcelController.php：1php artisan make:controller ExcelController --plain 然后在routes.php中定义相关路由：12Route::get(&apos;excel/export&apos;,&apos;ExcelController@export&apos;);Route::get(&apos;excel/import&apos;,&apos;ExcelController@import&apos;); 接下来我们先在ExcelController.php中定义export方法实现导出功能：1234567891011121314151617181920212223242526272829&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;use App\\Http\\Requests;use App\\Http\\Controllers\\Controller;use Excel;class ExcelController extends Controller&#123; //Excel文件导出功能 By Laravel学院 public function export()&#123; $cellData = [ [&apos;学号&apos;,&apos;姓名&apos;,&apos;成绩&apos;], [&apos;10001&apos;,&apos;AAAAA&apos;,&apos;99&apos;], [&apos;10002&apos;,&apos;BBBBB&apos;,&apos;92&apos;], [&apos;10003&apos;,&apos;CCCCC&apos;,&apos;95&apos;], [&apos;10004&apos;,&apos;DDDDD&apos;,&apos;89&apos;], [&apos;10005&apos;,&apos;EEEEE&apos;,&apos;96&apos;], ]; Excel::create(&apos;学生成绩&apos;,function($excel) use ($cellData)&#123; $excel-&gt;sheet(&apos;score&apos;, function($sheet) use ($cellData)&#123; $sheet-&gt;rows($cellData); &#125;); &#125;)-&gt;export(&apos;xls&apos;); &#125;&#125; 我们在浏览器中访问http://laravel.app:8000/excel/export，会导出一个名为学生成绩.xls的Excel文件： 如果你要导出csv或者xlsx文件，只需将export方法中的参数改成csv或xlsx即可。如果还要将该Excel文件保存到服务器上，可以使用store方法：12345Excel::create(&apos;学生成绩&apos;,function($excel) use ($cellData)&#123; $excel-&gt;sheet(&apos;score&apos;, function($sheet) use ($cellData)&#123; $sheet-&gt;rows($cellData); &#125;);&#125;)-&gt;store(&apos;xls&apos;)-&gt;export(&apos;xls&apos;); 文件默认保存到storage/exports目录下，如果出现文件名中文乱码，将上述代码文件名做如下修改即可：1iconv(&apos;UTF-8&apos;, &apos;GBK&apos;, &apos;学生成绩&apos;) 4、导入Excel文件我们将刚才保存到服务器上的Excel文件导入进来，导入很简单，使用Excel门面上的load方法即可：12345678//Excel文件导入功能 By Laravel学院public function import()&#123; $filePath = &apos;storage/exports/&apos;.iconv(&apos;UTF-8&apos;, &apos;GBK&apos;, &apos;学生成绩&apos;).&apos;.xls&apos;; Excel::load($filePath, function($reader) &#123; $data = $reader-&gt;all(); dd($data); &#125;);&#125; load方法基于项目根路径作为根目录，同样我们对中文进行了转码，否则会提示文件不存在。在浏览器中访问http://laravel.app:8000/excel/import，页面显示如下：","path":"2018/09/21/Laravel-Excel-实现-Excel-CSV-文件导入导出功能/","date":"09-21","excerpt":""},{"title":"npm启动内存溢出问题","text":"现象：npm或者webpack启动项目报内存溢出报错：FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory处理：要找到对应的npm或者webpack的cmd执行命令文件，然后加上参数max_old_space_size=4096例如1node --max_old_space_size=4096 &quot;%~dp0\\node_modules\\webpack-dev-server\\bin\\webpack-dev-server.js&quot; %* 问题处理追加：同一个问题，在某些电脑使用这种处理并不能解决问题，尝试升级了node的版本到v8.11，也一样存在，最后安装插件1npm install -g increase-memory-limit 然后运行1increase-memory-limit 然后在package.json文件增加配置12345678910111213&quot;scripts&quot;: &#123; &quot;fix-memory-limit&quot;: &quot;cross-env LIMIT=2048 increase-memory-limit&quot;&#125;,&quot;devDependencies&quot;: &#123; &quot;increase-memory-limit&quot;: &quot;^1.0.3&quot;, &quot;cross-env&quot;: &quot;^5.0.5&quot;&#125; 问题未重现","path":"2018/09/17/npm启动内存溢出问题/","date":"09-17","excerpt":""},{"title":"redis安装及数据类型简介","text":"一、简介：12345678910111213memcache：是key-value数据库数据类型：只支持key value数据过期策略：支持持久化：不支持（可以通过三方程序）主从复制：不支持虚拟内存：不支持使用场景：可以保存session，存放单一的数据，更加轻量级，效率更高 12345678910111213redis：是key-value数据库数据类型：支持五种数据类型过期策略：支持持久化：支持主从复制：支持虚拟内存：不支持支持五种数据类型，可以保存购物车的商品 二、编译安装redis 3.0.7本机编译安装redis 3.0.7：tar xvf redis-3.0.7.tar.gz cd redis-3.0.7 make PREFIX=/usr/local/redis install 制作启动脚本：cp utils/redis_init_script /etc/init.d/redisd chmod a+x /etc/init.d/redisd 1234567891011121314151617181920212223242526272829303132333435363738394041424344[root@node5 redis-3.0.7]# vim /etc/init.d/redisd #!/bin/sh## Simple Redis init.d script conceived to work on Linux systems# as it does use of the /proc filesystem.REDISPORT=6379EXEC=/usr/local/redis/bin/redis-serverCLIEXEC=/usr/local/redis/bin/redis-cliPIDFILE=/var/run/redis_$&#123;REDISPORT&#125;.pidCONF=&quot;/etc/redis/$&#123;REDISPORT&#125;.conf&quot;case &quot;$1&quot; in start) if [ -f $PIDFILE ] then echo &quot;$PIDFILE exists, process is already running or crashed&quot; else echo &quot;Starting Redis server...&quot; $EXEC $CONF fi ;; stop) if [ ! -f $PIDFILE ] then echo &quot;$PIDFILE does not exist, process is not running&quot; else PID=$(cat $PIDFILE) echo &quot;Stopping ...&quot; $CLIEXEC -p $REDISPORT shutdown while [ -x /proc/$&#123;PID&#125; ] do echo &quot;Waiting for Redis to shutdown ...&quot; sleep 1 done echo &quot;Redis stopped&quot; fi ;; *) echo &quot;Please use start or stop as first argument&quot; ;;esac 配置文件：123[root@node5 redis-3.0.7]# mkdir /etc/redis[root@node5 redis-3.0.7]# cp redis.conf /etc/redis/6379.conf #对应配置文件/etc/redis/6379.conf 启动测试：/etc/init.d/redisd start 1234567891011121314151617181920[root@node5 redis-3.0.7]# /etc/init.d/redisd startStarting Redis server...65171:M 21 Mar 07:14:15.712 * Increased maximum number of open files to 10032 (it was originally set to 1024). _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 3.0.7 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6379 | `-._ `._ / _.-&apos; | PID: 65171 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; 这是在前台启动的，如果要想在后台启动，需要改一下配置文件： daemonize no 改为 daemonize yes 然后在重新启动服务即可 通过salt-master批量安装：1、编辑redis.sls文件：/etc/salt/states/init 12345678910111213141516171819202122232425262728293031323334353637383940414243redis-install: file.managed: #调用file模块的managed方法 - name: /usr/local/src/redis-3.0.7.tar.gz #客户端的文件路径 - source: salt://init/files/redis-3.0.7.tar.gz #在服务器的路径 - user: root - group: root - mode: 755 cmd.run: #执行远程命令，使用cmd的run方法 - name: cd /usr/local/src/ &amp;&amp; tar xvf redis-3.0.7.tar.gz &amp;&amp; cd redis-3.0.7 &amp;&amp; make PREFIX=/usr/local/redis install #编译安装 - unless: test -d /usr/local/redis #如果目录存在就不安装了 - require: #依赖 - file: redis-install #编译之前需要依赖redis-install执行成功redis-config: file.managed: - name: /etc/redis/6379.conf #客户端的配置文件路径 - source: salt://init/files/6379.conf #服务器的配置文件路径 - user: root - group: root - mode: 644redis-service: file.managed: - name: /etc/init.d/redis - source: salt://init/files/redis - user: root - group: root - mode: 755 cmd.run: - name: chkconfig --add redis &amp;&amp; chkconfig redis on #设置服务开机启动 - unless: chkconfig --list | grep redis #如果已经在chkconfig --list列表就不执行上一步骤 service.running: #这是服务启动 - name: redis - enable: True - watch: #监控的文件 - file: redis-config - require: 服务启动依赖 redis-install和redis-service - cmd: redis-install - cmd: redis-service 2、准备文件：123456[root@node5 init]# ls files/redis #启动脚本files/redis[root@node5 init]# ls files/6379.conf #配置文件files/6379.conf[root@node5 init]# ls files/redis-3.0.7.tar.gz #源码包files/redis-3.0.7.tar.gz 3、执行命令：1[root@node5 init]# salt &quot;node6.a.com&quot; state.sls init.redis 4、客户端验证：123456789101112131415161718root@node6 ~]# /etc/init.d/redis startStarting Redis server...[root@node6 ~]# ss -tnlState Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 128 *:6379 *:* LISTEN 0 128 :::6379 :::* LISTEN 0 128 :::111 :::* LISTEN 0 128 *:111 *:* LISTEN 0 128 :::41586 :::* LISTEN 0 128 :::22 :::* LISTEN 0 128 *:22 *:* LISTEN 0 128 127.0.0.1:631 *:* LISTEN 0 128 ::1:631 :::* LISTEN 0 100 ::1:25 :::* LISTEN 0 100 127.0.0.1:25 *:* LISTEN 0 128 *:46715 *:* LISTEN 0 128 :::10050 :::* LISTEN 0 128 *:10050 *:* salt-master执行命令后后如果报错就根据返回的红色错误信息进行排错 三、redis数据类型格式3.1、字符串数据格式SET 设置key，设置的值都是字符串格式string：123456192.168.10.205:6379&gt; set key1 value1OK192.168.10.205:6379&gt; set key3 value3OK192.168.10.205:6379&gt; set key2 value2OK GET 获取key的值：12345678192.168.10.205:6379&gt; get key1 &quot;value1&quot;192.168.10.205:6379&gt; get key3 #获取指定的key的值&quot;value3&quot;不能一次多个key的值：192.168.10.205:6379&gt; get key1 key2(error) ERR wrong number of arguments for &apos;get&apos; command KEYS 显示所有的key123456192.168.10.205:6379&gt; KEYS *1) &quot;ss&quot;2) &quot;key2&quot;3) &quot;list1&quot;4) &quot;key1&quot;5) &quot;key4&quot; EXISTS 判断key是否存在：1234567192.168.10.205:6379&gt; EXISTS key1(integer) 1192.168.10.205:6379&gt; EXISTS key9(integer) 0返回1表示存在，0表示不存在 DEL 删除指定的key：1234192.168.10.205:6379&gt; del key1 key2 key9(integer) 2返回0表示没有指定的key可以删除，返回其他整数表示成功删除的key的数量，没有的key不报错 TYPE 获取key的类型1234567[root@node5 init]# redis-cli -h 192.168.10.205 -p 6379192.168.10.205:6379&gt; set key1 value1 #set keyOK 192.168.10.205:6379&gt; get key1 #获取key的值&quot;value1&quot; INFO： 当前服务器的状态 SELECT: 更换数据库，redis默认支持16个数据库，默认在数据库0，可以使用sekect 进行更换数据库123456192.168.10.205:6379&gt; SELECT 1OK192.168.10.205:6379[1]&gt; set key1 value1OK192.168.10.205:6379[1]&gt; KEYS *1) &quot;key1&quot; 清空整个数据库：FLUSHALL1192.168.10.205:6379[1]&gt; FLUSHALL APPEND:附加值给value123456127.0.0.1:6379&gt; get key1&quot;value1&quot;127.0.0.1:6379&gt; APPEND key1 cc(integer) 8127.0.0.1:6379&gt; get key1&quot;value1cc&quot; INCR:如果key不存在就创建并设置value默认为1:12345678910111213127.0.0.1:6379&gt; INCR num #如果key不存在就创建并设置默认值为1(integer) 1127.0.0.1:6379&gt; get num&quot;1&quot;127.0.0.1:6379&gt; INCR num #再次执行的值会自增1(integer) 2127.0.0.1:6379&gt; get num&quot;2&quot; 127.0.0.1:6379&gt; get key1 &quot;value1cc&quot; 127.0.0.1:6379&gt; INCR key1 #如果key已经存则报错 (error) ERR value is not an integer or out of range DECR:value自减1：12345678910127.0.0.1:6379&gt; get num&quot;5&quot;127.0.0.1:6379&gt; DECR num(integer) 4127.0.0.1:6379&gt; get num&quot;4&quot;127.0.0.1:6379&gt; DECR num(integer) 3127.0.0.1:6379&gt; get num&quot;3&quot; INCRBY ：指定自增value的整数值：12345678910127.0.0.1:6379&gt; get num&quot;13&quot;127.0.0.1:6379&gt; INCRBY num 7(integer) 20127.0.0.1:6379&gt; get num&quot;20&quot;127.0.0.1:6379&gt; INCRBY num 10(integer) 30127.0.0.1:6379&gt; get num&quot;30&quot; DECRBY：指定自检value的值：12345678910127.0.0.1:6379&gt; get num&quot;41&quot;127.0.0.1:6379&gt; DECRBY num 10(integer) 31127.0.0.1:6379&gt; get num&quot;31&quot;127.0.0.1:6379&gt; DECRBY num 10(integer) 21127.0.0.1:6379&gt; get num&quot;21&quot; INCRBYFLOAT ：设置浮点数的value12345678127.0.0.1:6379&gt; INCRBYFLOAT num1 0.1&quot;0.1&quot;127.0.0.1:6379&gt; INCRBYFLOAT num1 0.1&quot;0.2&quot;127.0.0.1:6379&gt; INCRBYFLOAT num1 0.1&quot;0.3&quot;127.0.0.1:6379&gt; get num1&quot;0.3&quot; MSET 和 MGET：批量创建和获取key123456127.0.0.1:6379&gt; MSET k1 v2 k2 v2 k3 v3 OK127.0.0.1:6379&gt; MGET k1 k2 k3 1) &quot;v2&quot;2) &quot;v2&quot;3) &quot;v3&quot; STRLEN：获取key字符串的长度12345678127.0.0.1:6379&gt; STRLEN key1(integer) 8127.0.0.1:6379&gt; STRLEN k1(integer) 2127.0.0.1:6379&gt; get key1&quot;value1cc&quot;127.0.0.1:6379&gt; get k1&quot;v2&quot; 3.2、散列数据类型：HSET：命令用于为哈希表中的字段赋值，如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作，如果字段已经存在于哈希表中，旧值将被覆盖HGET:获取key：12345678910111213127.0.0.1:6379&gt; HSET shouji name iphone(integer) 1127.0.0.1:6379&gt; HSET shouji color red(integer) 1127.0.0.1:6379&gt; HSET shouji price 4888(integer) 1127.0.0.1:6379&gt; HGET shouji name&quot;iphone&quot;127.0.0.1:6379&gt; HGET shouji color&quot;red&quot;127.0.0.1:6379&gt; HGET shouji price&quot;4888&quot; HGETALL:获取key的所有值1234567127.0.0.1:6379&gt; HGETALL shouji1) &quot;name&quot;2) &quot;iphone&quot;3) &quot;color&quot;4) &quot;red&quot;5) &quot;price&quot;6) &quot;4888&quot; HMSET、HMGET、HMGETALL:批量创建、批量获取并获取所有的key：123456789101112131415161718127.0.0.1:6379&gt; HMSET shouji name xiaoji color baise storge 16G #批量创建OK127.0.0.1:6379&gt; HMGET shouji name storge #批量获取1) &quot;xiaoji&quot; 2) &quot;16G&quot;127.0.0.1:6379&gt; HGETALL shouji #获取所有的key 1) &quot;name&quot; 2) &quot;xiaoji&quot; 3) &quot;color&quot; 4) &quot;baise&quot; 5) &quot;price&quot; 6) &quot;4888&quot; 7) &quot;name1&quot; 8) &quot;xiaomio&quot; 9) &quot;storge&quot;10) &quot;16G&quot; HDEL:删除指定的key1234567891011127.0.0.1:6379&gt; HDEL shouji name #删除值的key(integer) 1127.0.0.1:6379&gt; HGETALL shouji #再次查看1) &quot;color&quot;2) &quot;baise&quot;3) &quot;price&quot;4) &quot;4888&quot;5) &quot;name1&quot;6) &quot;xiaomio&quot;7) &quot;storge&quot;8) &quot;16G&quot; 3.3 列表数据类型：不同的数据类型的命令是不通用的，如list与string的命令是不能通用的。出了set命令之外LPUSH与RPUSH:12345678910127.0.0.1:6379&gt; LPUSH list1 a #从左侧添加(integer) 1127.0.0.1:6379&gt; LPUSH list1 b(integer) 2127.0.0.1:6379&gt; LPUSH list1 c(integer) 3127.0.0.1:6379&gt; RPUSH list 1 #从右侧添加(integer) 1 127.0.0.1:6379&gt; TYPE list1 #查看类型list LLEN:获取列表的长度：12345678127.0.0.1:6379&gt; LLEN list1(integer) 3LPOP 与 RPOP:从左侧和右侧弹出列表中的值:127.0.0.1:6379&gt; LPOP list1&quot;c&quot;127.0.0.1:6379&gt; RPOP list1&quot;a&quot; LINDEX：获取最后一个元素：LRANGE ：获取指定范围的元素123456789101112127.0.0.1:6379&gt; LINDEX list1 -1&quot;b&quot;127.0.0.1:6379&gt; LINDEX list1 3&quot;a&quot;127.0.0.1:6379&gt; LRANGE list1 0 -11) &quot;d&quot;2) &quot;c&quot;3) &quot;b&quot;4) &quot;a&quot;5) &quot;b&quot; 3.4、集合数据类型的操作：集合默认是无序的，列表是有序的，有序是只按照添加的循序保持位置SADD:创建并给集合赋值1234192.168.10.205:6379&gt; SADD set1 0 99 1(integer) 3192.168.10.205:6379&gt; SADD set1 a b c(integer) 3 SMEMBERS：获取集合中的所有值1234567192.168.10.205:6379&gt; SMEMBERS set11) &quot;1&quot;2) &quot;99&quot;3) &quot;0&quot;4) &quot;c&quot;5) &quot;b&quot;6) &quot;a&quot; SISMEMBER：判断一个值是不是在集合当中，在返回1，否则返回01234192.168.10.205:6379&gt; SISMEMBER set1 a(integer) 1192.168.10.205:6379&gt; SISMEMBER set1 p(integer) 0 SDIFF:求两个集合的差集：12345678192.168.10.205:6379&gt; SADD jihe1 1 2 3 a(integer) 4192.168.10.205:6379&gt; SADD jihe2 1 2 3 b(integer) 4192.168.10.205:6379&gt; SDIFF jihe1 jihe2 #差集，求集合1有而集合2没有的值1) &quot;a&quot;192.168.10.205:6379&gt; SDIFF jihe2 jihe11) &quot;b&quot; SINTER：求并集，即在多个集合当中共同包含的值，可以是多个集合12345192.168.10.205:6379&gt; SADD jihe3 2 3 c (integer) 3192.168.10.205:6379&gt; SINTER jihe1 jihe2 jihe31) &quot;2&quot;2) &quot;3&quot; SUNION：求并集，即在每个元素都出现的值只统计一次1234567192.168.10.205:6379&gt; SUNION jihe1 jihe2 jihe31) &quot;c&quot;2) &quot;1&quot;3) &quot;b&quot;4) &quot;3&quot;5) &quot;a&quot;6) &quot;2&quot; 3.5 有序队列：保持值的位置固定123456192.168.10.205:6379&gt; ZADD youxv 1 b 2 a 3 c #通过设置分数创建有序队列，值会安装自己的分数排列位置(integer) 3192.168.10.205:6379&gt; ZSCORE youxv a #获取值的分数&quot;2&quot;192.168.10.205:6379&gt; ZSCORE youxv b&quot;1&quot; ZRANGE：根据值的分数排序获取值1234192.168.10.205:6379&gt; ZRANGE youxv 0 3 #0和3为取值的下标范围，可以通过LEN统计，超出值的总数不报错1) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot;","path":"2018/09/14/redis安装及数据类型简介/","date":"09-14","excerpt":""},{"title":"laravel的资源路由resource","text":"路由列表1Route::resource(&apos;re&apos;,&apos;Admin\\ReController&apos;); Controller 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php namespace App\\Http\\Controllers\\Admin; use Illuminate\\Http\\Request;use App\\Http\\Controllers\\Controller;use Illuminate\\Support\\Facades\\Input; class ReController extends Controller&#123; //get.re 全部分类列表 public function index($id = null)&#123; echo &quot;这里是index方法不能传入参数&quot;; &#125; //get.re/create 添加分类 public function create()&#123; echo &quot;这里是create方法不能传入参数&quot;; &#125; //post.re 添加分类提交 public function store()&#123; echo &quot;这里是store方法不能传入参数&quot;; &#125; //get.re/&#123;id&#125; 显示单个分类 public function show($id)&#123; echo &quot;这里是show方法传入的参数是：&quot;.$id; dd(Input::all()); &#125; //get.re/&#123;id&#125;/edit 更新分类 public function edit($id)&#123; echo &quot;这里是edit方法传入的参数是：&quot;.$id; dd(Input::all()); &#125; //put.re/&#123;id&#125; 显示单个分类信息 public function update($id)&#123; echo &quot;这里是update方法传入的参数是：&quot;.$id; dd(Input::all()); &#125; //delete.re/&#123;id&#125; 删除单个分类 public function destroy($id)&#123; echo &quot;这里是destory方法传入的参数是：&quot;.$id; dd(Input::all()); &#125;&#125; blade模板123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;&#123;&#123;url(&apos;re&apos;)&#125;&#125;&quot; method= &quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;这里是index方法&quot; /&gt; &lt;/form&gt; &lt;form action=&quot;&#123;&#123;url(&apos;re/create&apos;)&#125;&#125;&quot; method= &quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;这里是create方法&quot; /&gt; &lt;/form&gt; &lt;form action=&quot;&#123;&#123;url(&apos;re/&apos;)&#125;&#125;&quot; method= &quot;post&quot;&gt; &#123;&#123;csrf_field()&#125;&#125; &lt;input type=&quot;submit&quot; value=&quot;这里是store方法&quot; /&gt; &lt;/form&gt; &lt;form action=&quot;&#123;&#123;url(&apos;re/123&apos;)&#125;&#125;&quot; method= &quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;这里是show方法&quot; /&gt; &lt;/form&gt; &lt;form action=&quot;&#123;&#123;url(&apos;re/123/edit&apos;)&#125;&#125;&quot; method= &quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;这里是edit方法&quot; /&gt; &lt;/form&gt; &lt;form action=&quot;&#123;&#123;url(&apos;re/123&apos;)&#125;&#125;&quot; method= &quot;POST&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;这里是update方法&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_token&quot; value=&quot;&#123;&#123;csrf_token()&#125;&#125;&quot; /&gt; &lt;/form&gt; &lt;form action=&quot;&#123;&#123;url(&apos;re/123&apos;)&#125;&#125;&quot; method= &quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;这里是destory方法&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_token&quot; value=&quot;&#123;&#123;csrf_token()&#125;&#125;&quot; /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;","path":"2018/09/14/laravel的资源路由resource/","date":"09-14","excerpt":""},{"title":"laravel小程序微信支付","text":"1.路由1234//得到预支付交易单Route::post(&apos;prepay_id&apos;, &apos;WeiXinXPayController@requestPayment&apos;);//小程序支付回掉Route::any(&apos;notify&apos;, &apos;APi\\WeiXinXPayController@notifyPay&apos;); 2.控制器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?phpnamespace App\\Http\\Controllers\\APi;use App\\Http\\Model\\Source\\Order\\Order;use App\\Http\\Model\\Source\\Order\\Pay;use App\\Http\\Model\\Source\\Pay\\WeiXinXPay;use Illuminate\\Http\\Request;class WeiXinXPayController extends BaseApiController&#123; public $config; public function __construct() &#123; $config = array( &apos;appid&apos;=&gt;&apos;xxxxxx&apos;, &apos;pay_mchid&apos;=&gt;&apos;xxxxxx&apos;, &apos;pay_apikey&apos;=&gt;&apos;xxxxxx&apos;, &apos;notify_url&apos;=&gt;&apos;xxxxxx&apos;, &apos;body&apos;=&gt;&apos;xxxxxx&apos; ); $this-&gt;config = $config; &#125; /** * 预支付请求接口(POST) * $openid openid * $body 商品简单描述 * $order_sn 订单编号 * $total_fee 金额 * json的数据 */ public function requestPayment(Request $request) &#123; $errors = new \\stdClass(); $object = $this-&gt;JsonToArray($request); $res = Order::where([&apos;order_id&apos;=&gt;trim($object[&apos;order_id&apos;]),&apos;openid&apos;=&gt;trim($object[&apos;openid&apos;])])-&gt;select(&apos;openid&apos;,&apos;price&apos;,&apos;pay_status&apos;,&apos;order_id&apos;)-&gt;first(); if( $res &amp;&amp; $res-&gt;pay_status == 0 ) &#123; $pay = new WeiXinXPay( $this-&gt;config ); $obj = new \\stdClass(); $obj-&gt;openid = $res-&gt;openid; $obj-&gt;body = $this-&gt;config[&apos;body&apos;]; $obj-&gt;order_sn = $res-&gt;order_id; $obj-&gt;total_fee = $res-&gt;price; $result = $pay-&gt;prepay( $obj ); $result = json_decode($result); if( $result-&gt;status == 1 ) &#123; $errors-&gt;status = 1; $errors-&gt;data = $result-&gt;data; return response()-&gt;json($errors, 200); &#125;else &#123; $errors-&gt;status = 0; $errors-&gt;result = &apos;支付异常&apos;; return response()-&gt;json($errors, 200); &#125; &#125;else &#123; $errors-&gt;status = 0; $errors-&gt;result = &apos;支付异常&apos;; return response()-&gt;json($errors, 200); &#125; &#125; /** * 支付回调 * 返回数组去修改支付订单数据 */ public function notifyPay() &#123; $notify = new WeiXinXPay( $this-&gt;config ); $data = $notify-&gt;notify(); if( $data ) &#123; //修改数据库订单状态 &#125; &#125;&#125; 3.类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236&lt;?phpnamespace App\\Http\\Model\\Source\\Pay;use Illuminate\\Database\\Eloquent\\Model;class WeiXinXPay extends Model&#123; public $config; public function __construct( $config ) &#123; $this-&gt;config = $config; &#125; /** * 预支付请求接口(POST) * 返回json的数据 */ public function prepay( $obj ) &#123; $config = $this-&gt;config; $unifiedorder = array( &apos;appid&apos; =&gt;$config[&apos;appid&apos;], &apos;mch_id&apos; =&gt;$config[&apos;pay_mchid&apos;], &apos;nonce_str&apos; =&gt;self::getNonceStr(), &apos;body&apos; =&gt;$obj-&gt;body, &apos;out_trade_no&apos; =&gt;$obj-&gt;order_sn, &apos;total_fee&apos; =&gt;$obj-&gt;total_fee * 100, &apos;spbill_create_ip&apos;=&gt;$_SERVER[&apos;REMOTE_ADDR&apos;], &apos;notify_url&apos; =&gt;$config[&apos;notify_url&apos;], &apos;trade_type&apos; =&gt;&apos;JSAPI&apos;, &apos;openid&apos; =&gt;$obj-&gt;openid ); $unifiedorder[&apos;sign&apos;] = self::makeSign($unifiedorder); //请求数据 $xmldata = self::array2xml($unifiedorder); $url = &apos;https://api.mch.weixin.qq.com/pay/unifiedorder&apos;; $res = self::curl_post_ssl($url, $xmldata); if(!$res)&#123; self::return_err(&quot;Can&apos;t connect the server&quot;); &#125; $content = self::xml2array($res); if(strval($content[&apos;result_code&apos;]) == &apos;FAIL&apos;)&#123; self::return_err(strval($content[&apos;err_code_des&apos;])); &#125; if(strval($content[&apos;return_code&apos;]) == &apos;FAIL&apos;)&#123; self::return_err(strval($content[&apos;return_msg&apos;])); &#125; //拼接小程序的接口数据 $resData = array( &apos;appId&apos; =&gt; strval($content[&apos;appid&apos;]), &apos;timeStamp&apos; =&gt; time(), &apos;nonceStr&apos; =&gt; self::getNonceStr(), &apos;package&apos; =&gt; &apos;prepay_id=&apos;.strval($content[&apos;prepay_id&apos;]), &apos;signType&apos; =&gt; &apos;MD5&apos;, ); //加密签名 $resData[&apos;paySign&apos;] = self::makeSign($resData); exit(json_encode(array(&apos;status&apos;=&gt;1,&apos;data&apos;=&gt;$resData))); &#125; /** * @return array|bool * 微信支付回调验证 * 返回数据 */ public function notify() &#123; //$xml = $GLOBALS[&apos;HTTP_RAW_POST_DATA&apos;]; $xml = file_get_contents(&apos;php://input&apos;); //将服务器返回的XML数据转化为数组 $data = self::xml2array($xml); // 保存微信服务器返回的签名sign $data_sign = $data[&apos;sign&apos;]; // sign不参与签名算法 unset($data[&apos;sign&apos;]); $sign = self::makeSign($data); // 判断签名是否正确 判断支付状态 if ( ($sign===$data_sign) &amp;&amp; ($data[&apos;return_code&apos;]==&apos;SUCCESS&apos;) &amp;&amp; ($data[&apos;result_code&apos;]==&apos;SUCCESS&apos;) ) &#123; $result = $data; //获取服务器返回的数据 //更新数据库 &#125;else &#123; $result = false; &#125; // 返回状态给微信服务器 if ( $result ) &#123; $str=&apos;&lt;xml&gt;&lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;&lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt;&lt;/xml&gt;&apos;; &#125;else &#123; $str=&apos;&lt;xml&gt;&lt;return_code&gt;&lt;![CDATA[FAIL]]&gt;&lt;/return_code&gt;&lt;return_msg&gt;&lt;![CDATA[签名失败]]&gt;&lt;/return_msg&gt;&lt;/xml&gt;&apos;; &#125; echo $str; return $result; &#125;//---------------------------------------------------------------用到的函数------------------------------------------------------------ /** * 错误返回提示 * @param string $errMsg 错误信息 * @param string $status 错误码 * @return json的数据 */ protected function return_err($errMsg=&apos;error&apos;,$status=0) &#123; exit(json_encode(array(&apos;status&apos;=&gt;$status,&apos;result&apos;=&gt;&apos;fail&apos;,&apos;errmsg&apos;=&gt;$errMsg))); &#125; /** * 正确返回 * @param array $data 要返回的数组 * @return json的数据 */ protected function return_data($data=array()) &#123; exit(json_encode(array(&apos;status&apos;=&gt;1,&apos;result&apos;=&gt;&apos;success&apos;,&apos;data&apos;=&gt;$data))); &#125; /** * 将一个数组转换为 XML 结构的字符串 * @param array $arr 要转换的数组 * @param int $level 节点层级, 1 为 Root. * @return string XML 结构的字符串 */ protected function array2xml($arr, $level = 1) &#123; $s = $level == 1 ? &quot;&lt;xml&gt;&quot; : &apos;&apos;; foreach($arr as $tagname =&gt; $value) &#123; if (is_numeric($tagname)) &#123; $tagname = $value[&apos;TagName&apos;]; unset($value[&apos;TagName&apos;]); &#125; if(!is_array($value)) &#123; $s .= &quot;&lt;&#123;$tagname&#125;&gt;&quot;.(!is_numeric($value) ? &apos;&lt;![CDATA[&apos; : &apos;&apos;).$value.(!is_numeric($value) ? &apos;]]&gt;&apos; : &apos;&apos;).&quot;&lt;/&#123;$tagname&#125;&gt;&quot;; &#125;else &#123; $s .= &quot;&lt;&#123;$tagname&#125;&gt;&quot; . $this-&gt;array2xml($value, $level + 1).&quot;&lt;/&#123;$tagname&#125;&gt;&quot;; &#125; &#125; $s = preg_replace(&quot;/([\\x01-\\x08\\x0b-\\x0c\\x0e-\\x1f])+/&quot;, &apos; &apos;, $s); return $level == 1 ? $s.&quot;&lt;/xml&gt;&quot; : $s; &#125; /** * 将xml转为array * @param string $xml xml字符串 * @return array 转换得到的数组 */ protected function xml2array($xml) &#123; //禁止引用外部xml实体 libxml_disable_entity_loader(true); $result= json_decode(json_encode(simplexml_load_string($xml, &apos;SimpleXMLElement&apos;, LIBXML_NOCDATA)), true); return $result; &#125; /** * * 产生随机字符串，不长于32位 * @param int $length * @return 产生的随机字符串 */ protected function getNonceStr($length = 32) &#123; $chars = &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;; $str =&quot;&quot;; for ( $i = 0; $i &lt; $length; $i++ ) &#123; $str .= substr($chars, mt_rand(0, strlen($chars)-1), 1); &#125; return $str; &#125; /** * 生成签名 * @return 签名 */ protected function makeSign($data) &#123; //获取微信支付秘钥 $key = $this-&gt;config[&apos;pay_apikey&apos;]; //去空 $data = array_filter($data); //签名步骤一：按字典序排序参数 ksort($data); $string_a = http_build_query($data); $string_a = urldecode($string_a); //签名步骤二：在string后加入KEY $string_sign_temp = $string_a.&quot;&amp;key=&quot;.$key; //签名步骤三：MD5加密 $sign = md5($string_sign_temp); // 签名步骤四：所有字符转为大写 $result=strtoupper($sign); return $result; &#125; /** * 微信支付发起请求 */ protected function curl_post_ssl($url, $xmldata, $second=30,$aHeader=array()) &#123; $ch = curl_init(); //超时时间 curl_setopt($ch,CURLOPT_TIMEOUT,$second); curl_setopt($ch,CURLOPT_RETURNTRANSFER, 1); //这里设置代理，如果有的话 //curl_setopt($ch,CURLOPT_PROXY, &apos;10.206.30.98&apos;); //curl_setopt($ch,CURLOPT_PROXYPORT, 8080); curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_SSL_VERIFYPEER,false); curl_setopt($ch,CURLOPT_SSL_VERIFYHOST,false); if( count($aHeader) &gt;= 1 )&#123; curl_setopt($ch, CURLOPT_HTTPHEADER, $aHeader); &#125; curl_setopt($ch,CURLOPT_POST, 1); curl_setopt($ch,CURLOPT_POSTFIELDS,$xmldata); $data = curl_exec($ch); if($data)&#123; curl_close($ch); return $data; &#125; else &#123; $error = curl_errno($ch); echo &quot;call faild, errorCode:$error\\n&quot;; curl_close($ch); return false; &#125; &#125;&#125; 4.小程序发起123456789101112131415161718192021222324252627282930313233/** * 请求支付数据 */ pay: function ( order_id ) &#123; var that = this; var url = _data.get_api_prepay_id; //得到预支付交易单地址这个请求是自己写的你可以用官方的 var openid = wx.getStorageSync(&apos;openid&apos;); var resdata = &#123; &apos;openid&apos;: openid, &apos;order_id&apos;: order_id &#125;; _httpHelper.httpPost(url, resdata, function (res) &#123; if ( res.status == 1 )&#123; that.Payment(res.data); &#125;else&#123; wx.showToast(&#123; title: &apos;支付失败&apos;, icon: &apos;loading&apos;, duration: 20000 &#125;); &#125; &#125;); &#125;, Payment: function (data) &#123; wx.requestPayment(&#123; &apos;timeStamp&apos;: String(data.timeStamp), &apos;nonceStr&apos;: data.nonceStr, &apos;package&apos;: data.package, &apos;signType&apos;: data.signType, &apos;paySign&apos;: data.paySign, &apos;success&apos;: function (res)&#123; wx.redirectTo(&#123; url: &apos;../user/my&apos; &#125;) &#125;, &apos;fail&apos;: function (res)&#123; wx.showToast(&#123; title: &apos;支付失败&apos;, icon: &apos;loading&apos;, duration: 20000 &#125;); &#125; &#125;) &#125;","path":"2018/09/14/laravel小程序微信支付/","date":"09-14","excerpt":""},{"title":"常用 Git 命令","text":"一、新建代码库123456789101112# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。1234567891011121314# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件123456789101112131415161718192021222324# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交1234567891011121314151617181920212223242526# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend ... 五、分支1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete$ git branch -dr#####六、标签# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached []# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 八、远程同步1234567891011121314151617181920212223242526272829303132# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销1234567891011121314151617181920212223242526272829303132333435363738# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到工作区$ git checkout [commit] [file]# 恢复上一个commit的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] 十、其他1234567891011121314151617181920# 生成一个可供发布的压缩包$ git archive# 备份当前工作区的内容$ git stash# 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容$ git stash pop#显示Git栈内的所有备份$ git stash list#清空Git栈$ git stash clear","path":"2018/09/14/常用-Git-命令/","date":"09-14","excerpt":""},{"title":"MySql函数字典","text":"对于针对字符串位置的操作，第一个位置被标记为1。ASCII(str)返回字符串str的最左面字符的ASCII代码值。如果str是空字符串，返回0。如果str是NULL，返回NULL。123456mysql&gt; select ASCII(&apos;2&apos;); -&gt; 50mysql&gt; select ASCII(2); -&gt; 50mysql&gt; select ASCII(&apos;dx&apos;); -&gt; 100 也可参见ORD()函数。ORD(str)如果字符串str最左面字符是一个多字节字符，通过以格式((first byte ASCII code)256+(second byte ASCII code))[256+third byte ASCII code…]返回字符的ASCII代码值来返回多字节字符代码。如果最左面的字符不是一个多字节字符。返回与ASCII()函数返回的相同值。12mysql&gt; select ORD(&apos;2&apos;); -&gt; 50 CONV(N,from_base,to_base)在不同的数字基之间变换数字。返回数字N的字符串数字，从from_base基变换为to_base基，如果任何参数是NULL，返回NULL。参数N解释为一个整数，但是可以指定为一个整数或一个字符串。最小基是2且最大的基是36。如果to_base是一个负数，N被认为是一个有符号数，否则，N被当作无符号数。 CONV以64位点精度工作。12345678mysql&gt; select CONV(&quot;a&quot;,16,2); -&gt; &apos;1010&apos;mysql&gt; select CONV(&quot;6E&quot;,18,8); -&gt; &apos;172&apos;mysql&gt; select CONV(-17,10,-18); -&gt; &apos;-H&apos;mysql&gt; select CONV(10+&quot;10&quot;+&apos;10&apos;+0xa,10,10); -&gt; &apos;40&apos; BIN(N)返回二进制值N的一个字符串表示，在此N是一个长整数(BIGINT)数字，这等价于CONV(N,10,2)。如果N是NULL，返回NULL。12mysql&gt; select BIN(12); -&gt; &apos;1100&apos; OCT(N)返回八进制值N的一个字符串的表示，在此N是一个长整型数字，这等价于CONV(N,10,8)。如果N是NULL，返回NULL。12mysql&gt; select OCT(12); -&gt; &apos;14&apos; HEX(N)返回十六进制值N一个字符串的表示，在此N是一个长整型(BIGINT)数字，这等价于CONV(N,10,16)。如果N是NULL，返回NULL。12mysql&gt; select HEX(255); -&gt; &apos;FF&apos; CHAR(N,…)CHAR()将参数解释为整数并且返回由这些整数的ASCII代码字符组成的一个字符串。NULL值被跳过。1234mysql&gt; select CHAR(77,121,83,81,&apos;76&apos;); -&gt; &apos;MySQL&apos;mysql&gt; select CHAR(77,77.3,&apos;77.3&apos;); -&gt; &apos;MMM&apos; CONCAT(str1,str2,…)返回来自于参数连结的字符串。如果任何参数是NULL，返回NULL。可以有超过2个的参数。一个数字参数被变换为等价的字符串形式。123456mysql&gt; select CONCAT(&apos;My&apos;, &apos;S&apos;, &apos;QL&apos;); -&gt; &apos;MySQL&apos;mysql&gt; select CONCAT(&apos;My&apos;, NULL, &apos;QL&apos;); -&gt; NULLmysql&gt; select CONCAT(14.3); -&gt; &apos;14.3&apos; LENGTH(str) OCTET_LENGTH(str) CHAR_LENGTH(str)CHARACTER_LENGTH(str)返回字符串str的长度。1234mysql&gt; select LENGTH(&apos;text&apos;); -&gt; 4mysql&gt; select OCTET_LENGTH(&apos;text&apos;); -&gt; 4 注意，对于多字节字符，其CHAR_LENGTH()仅计算一次。 LOCATE(substr,str) POSITION(substr IN str)返回子串substr在字符串str第一个出现的位置，如果substr不是在str里面，返回0.1234mysql&gt; select LOCATE(&apos;bar&apos;, &apos;foobarbar&apos;); -&gt; 4mysql&gt; select LOCATE(&apos;xbar&apos;, &apos;foobar&apos;); -&gt; 0 该函数是多字节可靠的。 LOCATE(substr,str,pos)返回子串substr在字符串str第一个出现的位置，从位置pos开始。如果substr不是在str里面，返回0。12mysql&gt; select LOCATE(&apos;bar&apos;, &apos;foobarbar&apos;,5); -&gt; 7 这函数是多字节可靠的。 INSTR(str,substr)返回子串substr在字符串str中的第一个出现的位置。这与有2个参数形式的LOCATE()相同，除了参数被颠倒。1234mysql&gt; select INSTR(&apos;foobarbar&apos;, &apos;bar&apos;); -&gt; 4mysql&gt; select INSTR(&apos;xbar&apos;, &apos;foobar&apos;); -&gt; 0 这函数是多字节可靠的。 LPAD(str,len,padstr)返回字符串str，左面用字符串padstr填补直到str是len个字符长。12mysql&gt; select LPAD(&apos;hi&apos;,4,&apos;??&apos;); -&gt; &apos;??hi&apos; RPAD(str,len,padstr)返回字符串str，右面用字符串padstr填补直到str是len个字符长。12mysql&gt; select RPAD(&apos;hi&apos;,5,&apos;?&apos;); -&gt; &apos;hi???&apos; LEFT(str,len)返回字符串str的最左面len个字符。12mysql&gt; select LEFT(&apos;foobarbar&apos;, 5); -&gt; &apos;fooba&apos; 该函数是多字节可靠的。 RIGHT(str,len)返回字符串str的最右面len个字符。12mysql&gt; select RIGHT(&apos;foobarbar&apos;, 4); -&gt; &apos;rbar&apos; 该函数是多字节可靠的。 SUBSTRING(str,pos,len)SUBSTRING(str FROM pos FOR len)MID(str,pos,len)从字符串str返回一个len个字符的子串，从位置pos开始。使用FROM的变种形式是ANSI SQL92语法。12mysql&gt; select SUBSTRING(&apos;Quadratically&apos;,5,6); -&gt; &apos;ratica&apos; 该函数是多字节可靠的。 SUBSTRING(str,pos) SUBSTRING(str FROM pos)从字符串str的起始位置pos返回一个子串。1234mysql&gt; select SUBSTRING(&apos;Quadratically&apos;,5); -&gt; &apos;ratically&apos;mysql&gt; select SUBSTRING(&apos;foobarbar&apos; FROM 4); -&gt; &apos;barbar&apos; 该函数是多字节可靠的。 SUBSTRING_INDEX(str,delim,count)返回从字符串str的第count个出现的分隔符delim之后的子串。如果count是正数，返回最后的分隔符到左边(从左边数) 的所有字符。如果count是负数，返回最后的分隔符到右边的所有字符(从右边数)。1234mysql&gt; select SUBSTRING_INDEX(&apos;www.mysql.com&apos;, &apos;.&apos;, 2); -&gt; &apos;www.mysql&apos;mysql&gt; select SUBSTRING_INDEX(&apos;www.mysql.com&apos;, &apos;.&apos;, -2); -&gt; &apos;mysql.com&apos; 该函数对多字节是可靠的。 LTRIM(str)返回删除了其前置空格字符的字符串str。12mysql&gt; select LTRIM(&apos; barbar&apos;); -&gt; &apos;barbar&apos; RTRIM(str)返回删除了其拖后空格字符的字符串str。12mysql&gt; select RTRIM(&apos;barbar &apos;); -&gt; &apos;barbar&apos; 该函数对多字节是可靠的。 TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str)返回字符串str，其所有remstr前缀或后缀被删除了。如果没有修饰符BOTH、LEADING或TRAILING给出，BOTH被假定。如果remstr没被指定，空格被删除。12345678mysql&gt; select TRIM(&apos; bar &apos;); -&gt; &apos;bar&apos;mysql&gt; select TRIM(LEADING &apos;x&apos; FROM &apos;xxxbarxxx&apos;); -&gt; &apos;barxxx&apos;mysql&gt; select TRIM(BOTH &apos;x&apos; FROM &apos;xxxbarxxx&apos;); -&gt; &apos;bar&apos;mysql&gt; select TRIM(TRAILING &apos;xyz&apos; FROM &apos;barxxyz&apos;); -&gt; &apos;barx&apos; 该函数对多字节是可靠的。 SOUNDEX(str)返回str的一个同音字符串。听起来“大致相同”的2个字符串应该有相同的同音字符串。一个“标准”的同音字符串长是4个字符，但是SOUNDEX()函数返回一个任意长的字符串。你可以在结果上使用SUBSTRING()得到一个“标准”的 同音串。所有非数字字母字符在给定的字符串中被忽略。所有在A-Z之外的字符国际字母被当作元音。1234mysql&gt; select SOUNDEX(&apos;Hello&apos;); -&gt; &apos;H400&apos;mysql&gt; select SOUNDEX(&apos;Quadratically&apos;); -&gt; &apos;Q36324&apos; SPACE(N)返回由N个空格字符组成的一个字符串。12mysql&gt; select SPACE(6); -&gt; &apos; &apos; REPLACE(str,from_str,to_str)返回字符串str，其字符串from_str的所有出现由字符串to_str代替。12mysql&gt; select REPLACE(&apos;www.mysql.com&apos;, &apos;w&apos;, &apos;Ww&apos;); -&gt; &apos;WwWwWw.mysql.com&apos; 该函数对多字节是可靠的。 REPEAT(str,count)返回由重复countTimes次的字符串str组成的一个字符串。如果count &lt;= 0，返回一个空字符串。如果str或count是NULL，返回NULL。12mysql&gt; select REPEAT(&apos;MySQL&apos;, 3); -&gt; &apos;MySQLMySQLMySQL&apos; REVERSE(str)返回颠倒字符顺序的字符串str。12mysql&gt; select REVERSE(&apos;abc&apos;); -&gt; &apos;cba&apos; 该函数对多字节可靠的。 INSERT(str,pos,len,newstr)返回字符串str，在位置pos起始的子串且len个字符长得子串由字符串newstr代替。12mysql&gt; select INSERT(&apos;Quadratic&apos;, 3, 4, &apos;What&apos;); -&gt; &apos;QuWhattic&apos; 该函数对多字节是可靠的。 ELT(N,str1,str2,str3,…)如果N= 1，返回str1，如果N= 2，返回str2，等等。如果N小于1或大于参数个数，返回NULL。ELT()是FIELD()反运算。1234mysql&gt; select ELT(1, &apos;ej&apos;, &apos;Heja&apos;, &apos;hej&apos;, &apos;foo&apos;); -&gt; &apos;ej&apos;mysql&gt; select ELT(4, &apos;ej&apos;, &apos;Heja&apos;, &apos;hej&apos;, &apos;foo&apos;); -&gt; &apos;foo&apos; FIELD(str,str1,str2,str3,…)返回str在str1, str2, str3, …清单的索引。如果str没找到，返回0。FIELD()是ELT()反运算。1234mysql&gt; select FIELD(&apos;ej&apos;, &apos;Hej&apos;, &apos;ej&apos;, &apos;Heja&apos;, &apos;hej&apos;, &apos;foo&apos;); -&gt; 2mysql&gt; select FIELD(&apos;fo&apos;, &apos;Hej&apos;, &apos;ej&apos;, &apos;Heja&apos;, &apos;hej&apos;, &apos;foo&apos;); -&gt; 0 FIND_IN_SET(str,strlist)如果字符串str在由N子串组成的表strlist之中，返回一个1到N的值。一个字符串表是被“,”分隔的子串组成的一个字符串。如果第一个参数是一个常数字符串并且第二个参数是一种类型为SET的列，FIND_IN_SET()函数被优化而使用位运算！如果str不是在strlist里面或如果strlist是空字符串，返回0。如果任何一个参数是NULL，返回NULL。如果第一个参数包含一个“,”，该函数将工作不正常。12mysql&gt; SELECT FIND_IN_SET(&apos;b&apos;,&apos;a,b,c,d&apos;); -&gt; 2 MAKE_SET(bits,str1,str2,…)返回一个集合 (包含由“,”字符分隔的子串组成的一个字符串)，由相应的位在bits集合中的的字符串组成。str1对应于位0，str2对应位1，等等。在str1, str2, …中的NULL串不添加到结果中。123456mysql&gt; SELECT MAKE_SET(1,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;); -&gt; &apos;a&apos;mysql&gt; SELECT MAKE_SET(1 | 4,&apos;hello&apos;,&apos;nice&apos;,&apos;world&apos;); -&gt; &apos;hello,world&apos;mysql&gt; SELECT MAKE_SET(0,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;); -&gt; &apos;&apos; EXPORT_SET(bits,on,off,[separator,[number_of_bits]])返回一个字符串，在这里对于在“bits”中设定每一位，你得到一个“on”字符串，并且对于每个复位(reset)的位，你得到一个“off”字符串。每个字符串用“separator”分隔(缺省“,”)，并且只有“bits”的“number_of_bits” (缺省64)位被使用。12mysql&gt; select EXPORT_SET(5,&apos;Y&apos;,&apos;N&apos;,&apos;,&apos;,4) -&gt; Y,N,Y,N LCASE(str) LOWER(str)返回字符串str，根据当前字符集映射(缺省是ISO-8859-1 Latin1)把所有的字符改变成小写。该函数对多字节是可靠的。12mysql&gt; select LCASE(&apos;QUADRATICALLY&apos;); -&gt; &apos;quadratically&apos; UCASE(str) UPPER(str)返回字符串str，根据当前字符集映射(缺省是ISO-8859-1 Latin1)把所有的字符改变成大写。该函数对多字节是可靠的。12mysql&gt; select UCASE(&apos;Hej&apos;); -&gt; &apos;HEJ&apos; 该函数对多字节是可靠的。 LOAD_FILE(file_name)读入文件并且作为一个字符串返回文件内容。文件必须在服务器上，你必须指定到文件的完整路径名，而且你必须有file权限。文件必须所有内容都是可读的并且小于max_allowed_packet。如果文件不存在或由于上面原因之一不能被读出，函数返回NULL。123mysql&gt; UPDATE table_name SET blob_column=LOAD_FILE(&quot;/tmp/picture&quot;) WHERE id=1; MySQL必要时自动变换数字为字符串，并且反过来也如此：1234mysql&gt; SELECT 1+&quot;1&quot;; -&gt; 2mysql&gt; SELECT CONCAT(2,&apos; test&apos;); -&gt; &apos;2 test&apos; 如果你想要明确地变换一个数字到一个字符串，把它作为参数传递到CONCAT()。如果字符串函数提供一个二进制字符串作为参数，结果字符串也是一个二进制字符串。被变换到一个字符串的数字被当作是一个二进制字符串。这仅影响比较mysql 时间函数用法集合这里是一个使用日期函数的例子。下面的查询选择了所有记录，其date_col的值是在最后30天以内：12mysql&gt; SELECT something FROM table WHERE TO_DAYS(NOW()) - TO_DAYS(date_col) &lt;= 30; DAYOFWEEK(date)返回日期date的星期索引(1=星期天，2=星期一, ……7=星期六)。这些索引值对应于ODBC标准。12mysql&gt; select DAYOFWEEK(&apos;1998-02-03&apos;); -&gt; 3 WEEKDAY(date)返回date的星期索引(0=星期一，1=星期二, ……6= 星期天)。1234mysql&gt; select WEEKDAY(&apos;1997-10-04 22:23:00&apos;); -&gt; 5 mysql&gt; select WEEKDAY(&apos;1997-11-05&apos;); -&gt; 2 DAYOFMONTH(date)返回date的月份中日期，在1到31范围内。12mysql&gt; select DAYOFMONTH(&apos;1998-02-03&apos;); -&gt; 3 DAYOFYEAR(date)返回date在一年中的日数, 在1到366范围内。12mysql&gt; select DAYOFYEAR(&apos;1998-02-03&apos;); -&gt; 34 MONTH(date)返回date的月份，范围1到12。12mysql&gt; select MONTH(&apos;1998-02-03&apos;); -&gt; 2 DAYNAME(date)返回date的星期名字。12mysql&gt; select DAYNAME(&quot;1998-02-05&quot;); -&gt; &apos;Thursday&apos; MONTHNAME(date)返回date的月份名字。12mysql&gt; select MONTHNAME(&quot;1998-02-05&quot;); -&gt; &apos;February&apos; QUARTER(date)返回date一年中的季度，范围1到4。12mysql&gt; select QUARTER(&apos;98-04-01&apos;); -&gt; 2 WEEK(date)WEEK(date,first)对于星期天是一周的第一天的地方，有一个单个参数，返回date的周数，范围在0到52。2个参数形式WEEK()允许你指定星期是否开始于星期天或星期一。如果第二个参数是0，星期从星期天开始，如果第二个参数是1，从星期一开始。123456mysql&gt; select WEEK(&apos;1998-02-20&apos;); -&gt; 7 mysql&gt; select WEEK(&apos;1998-02-20&apos;,0); -&gt; 7 mysql&gt; select WEEK(&apos;1998-02-20&apos;,1); -&gt; 8 YEAR(date)返回date的年份，范围在1000到9999。12mysql&gt; select YEAR(&apos;98-02-03&apos;); -&gt; 1998 HOUR(time)返回time的小时，范围是0到23。12mysql&gt; select HOUR(&apos;10:05:03&apos;); -&gt; 10 MINUTE(time)返回time的分钟，范围是0到59。12mysql&gt; select MINUTE(&apos;98-02-03 10:05:03&apos;); -&gt; 5 SECOND(time)回来time的秒数，范围是0到59。12mysql&gt; select SECOND(&apos;10:05:03&apos;); -&gt; 3 PERIOD_ADD(P,N)增加N个月到阶段P（以格式YYMM或YYYYMM)。以格式YYYYMM返回值。注意阶段参数P不是日期值。12mysql&gt; select PERIOD_ADD(9801,2); -&gt; 199803 PERIOD_DIFF(P1,P2)返回在时期P1和P2之间月数，P1和P2应该以格式YYMM或YYYYMM。注意，时期参数P1和P2不是日期值。12mysql&gt; select PERIOD_DIFF(9802,199703); -&gt; 11 DATE_ADD(date,INTERVAL expr type)DATE_SUB(date,INTERVAL expr type)ADDDATE(date,INTERVAL expr type)SUBDATE(date,INTERVAL expr type)这些功能执行日期运算。对于MySQL 3.22，他们是新的。ADDDATE()和SUBDATE()是DATE_ADD()和DATE_SUB()的同义词。 在MySQL 3.23中，你可以使用+和-而不是DATE_ADD()和DATE_SUB()。（见例子）date是一个指定开始日期的DATETIME或DATE值，expr是指定加到开始日期或从开始日期减去的间隔值一个表达式，expr是一个字符串；它可以以一个“-”开始表示负间隔。type是一个关键词，指明表达式应该如何被解释。EXTRACT(type FROM date)函数从日期 中返回“type”间隔。下表显示了type和expr参数怎样被关联： type值 含义 期望的expr格式12345678910111213SECOND 秒 SECONDS MINUTE 分钟 MINUTES HOUR 时间 HOURS DAY 天 DAYS MONTH 月 MONTHS YEAR 年 YEARS MINUTE_SECOND 分钟和秒 &quot;MINUTES:SECONDS&quot; HOUR_MINUTE 小时和分钟 &quot;HOURS:MINUTES&quot; DAY_HOUR 天和小时 &quot;DAYS HOURS&quot; YEAR_MONTH 年和月 &quot;YEARS-MONTHS&quot; HOUR_SECOND 小时, 分钟， &quot;HOURS:MINUTES:SECONDS&quot; DAY_MINUTE 天, 小时, 分钟 &quot;DAYS HOURS:MINUTES&quot; DAY_SECOND 天, 小时, 分钟, 秒 &quot;DAYS HOURS:MINUTES:SECONDS&quot; MySQL在expr格式中允许任何标点分隔符。表示显示的是建议的分隔符。如果date参数是一个DATE值并且你的计算仅仅包含YEAR、MONTH和DAY部分(即，没有时间部分)，结果是一个DATE值。否则结果是一个DATETIME值。1234567891011121314151617181920212223242526272829mysql&gt; SELECT &quot;1997-12-31 23:59:59&quot; + INTERVAL 1 SECOND; -&gt; 1998-01-01 00:00:00 mysql&gt; SELECT INTERVAL 1 DAY + &quot;1997-12-31&quot;; -&gt; 1998-01-01 mysql&gt; SELECT &quot;1998-01-01&quot; - INTERVAL 1 SECOND; -&gt; 1997-12-31 23:59:59 mysql&gt; SELECT DATE_ADD(&quot;1997-12-31 23:59:59&quot;, INTERVAL 1 SECOND); -&gt; 1998-01-01 00:00:00 mysql&gt; SELECT DATE_ADD(&quot;1997-12-31 23:59:59&quot;, INTERVAL 1 DAY); -&gt; 1998-01-01 23:59:59 mysql&gt; SELECT DATE_ADD(&quot;1997-12-31 23:59:59&quot;, INTERVAL &quot;1:1&quot; MINUTE_SECOND); -&gt; 1998-01-01 00:01:00 mysql&gt; SELECT DATE_SUB(&quot;1998-01-01 00:00:00&quot;, INTERVAL &quot;1 1:1:1&quot; DAY_SECOND); -&gt; 1997-12-30 22:58:59 mysql&gt; SELECT DATE_ADD(&quot;1998-01-01 00:00:00&quot;, INTERVAL &quot;-1 10&quot; DAY_HOUR); -&gt; 1997-12-30 14:00:00 mysql&gt; SELECT DATE_SUB(&quot;1998-01-02&quot;, INTERVAL 31 DAY); -&gt; 1997-12-02 mysql&gt; SELECT EXTRACT(YEAR FROM &quot;1999-07-02&quot;); -&gt; 1999 mysql&gt; SELECT EXTRACT(YEAR_MONTH FROM &quot;1999-07-02 01:02:03&quot;); -&gt; 199907 mysql&gt; SELECT EXTRACT(DAY_MINUTE FROM &quot;1999-07-02 01:02:03&quot;); -&gt; 20102 如果你指定太短的间隔值(不包括type关键词期望的间隔部分)，MySQL假设你省掉了间隔值的最左面部分。例如，如果你指定一个type是DAY_SECOND，值expr被希望有天、小时、分钟和秒部分。如果你象”1:10”这样指定值，MySQL假设日子和小时部分是丢失的并且值代表分钟和秒。换句话说，”1:10” DAY_SECOND以它等价于”1:10” MINUTE_SECOND的方式解释，这对那MySQL解释TIME值表示经过的时间而非作为一天的时间的方式有二义性。如果你使用确实不正确的日期，结果是NULL。如果你增加MONTH、YEAR_MONTH或YEAR并且结果日期大于新月份的最大值天数，日子在新月用最大的天调整。12mysql&gt; select DATE_ADD(&apos;1998-01-30&apos;, Interval 1 month); -&gt; 1998-02-28 注意，从前面的例子中词INTERVAL和type关键词不是区分大小写的。 TO_DAYS(date)给出一个日期date，返回一个天数(从0年的天数)。1234mysql&gt; select TO_DAYS(950501); -&gt; 728779 mysql&gt; select TO_DAYS(&apos;1997-10-07&apos;); -&gt; 729669 TO_DAYS()不打算用于使用格列高里历(1582)出现前的值。FROM_DAYS(N)给出一个天数N，返回一个DATE值。12mysql&gt; select FROM_DAYS(729669); -&gt; &apos;1997-10-07&apos; DATE_FORMAT(date,format)根据format字符串格式化date值。下列修饰符可以被用在format字符串中： %M 月名字(January……December)1234567891011121314151617181920212223242526%W 星期名字(Sunday……Saturday) %D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。） %Y 年, 数字, 4 位 %y 年, 数字, 2 位 %a 缩写的星期名字(Sun……Sat) %d 月份中的天数, 数字(00……31) %e 月份中的天数, 数字(0……31) %m 月, 数字(01……12) %c 月, 数字(1……12) %b 缩写的月份名字(Jan……Dec) %j 一年中的天数(001……366) %H 小时(00……23) %k 小时(0……23) %h 小时(01……12) %I 小时(01……12) %l 小时(1……12) %i 分钟, 数字(00……59) %r 时间,12 小时(hh:mm:ss [AP]M) %T 时间,24 小时(hh:mm:ss) %S 秒(00……59) %s 秒(00……59) %p AM或PM %w 一个星期中的天数(0=Sunday ……6=Saturday ） %U 星期(0……52), 这里星期天是星期的第一天 %u 星期(0……52), 这里星期一是星期的第一天 %% 一个文字“%”。 所有的其他字符不做解释被复制到结果中。12345678mysql&gt; select DATE_FORMAT(&apos;1997-10-04 22:23:00&apos;, &apos;%W %M %Y&apos;); -&gt; &apos;Saturday October 1997&apos; mysql&gt; select DATE_FORMAT(&apos;1997-10-04 22:23:00&apos;, &apos;%H:%i:%s&apos;); -&gt; &apos;22:23:00&apos; mysql&gt; select DATE_FORMAT(&apos;1997-10-04 22:23:00&apos;, &apos;%D %y %a %d %m %b %j&apos;); -&gt; &apos;4th 97 Sat 04 10 Oct 277&apos; mysql&gt; select DATE_FORMAT(&apos;1997-10-04 22:23:00&apos;, &apos;%H %k %I %r %T %S %w&apos;); -&gt; &apos;22 22 10 10:23:00 PM 22:23:00 00 6&apos; MySQL3.23中，在格式修饰符字符前需要%。在MySQL更早的版本中，%是可选的。 TIME_FORMAT(time,format)这象上面的DATE_FORMAT()函数一样使用，但是format字符串只能包含处理小时、分钟和秒的那些格式修饰符。其他修饰符产生一个NULL值或0。 CURDATE() CURRENT_DATE以’YYYY-MM-DD’或YYYYMMDD格式返回今天日期值，取决于函数是在一个字符串还是数字上下文被使用。1234mysql&gt; select CURDATE(); -&gt; &apos;1997-12-15&apos; mysql&gt; select CURDATE() + 0; -&gt; 19971215 CURTIME()CURRENT_TIME以’HH:MM:SS’或HHMMSS格式返回当前时间值，取决于函数是在一个字符串还是在数字的上下文被使用。1234mysql&gt; select CURTIME(); -&gt; &apos;23:50:26&apos; mysql&gt; select CURTIME() + 0; -&gt; 235026 NOW()SYSDATE()CURRENT_TIMESTAMP以’YYYY-MM-DD HH:MM:SS’或YYYYMMDDHHMMSS格式返回当前的日期和时间，取决于函数是在一个字符串还是在数字的上下文被使用。1234mysql&gt; select NOW(); -&gt; &apos;1997-12-15 23:50:26&apos; mysql&gt; select NOW() + 0; -&gt; 19971215235026 UNIX_TIMESTAMP()UNIX_TIMESTAMP(date)如果没有参数调用，返回一个Unix时间戳记(从’1970-01-01 00:00:00’GMT开始的秒数)。如果UNIX_TIMESTAMP()用一个date参数被调用，它返回从’1970-01-01 00:00:00’ GMT开始的秒数值。date可以是一个DATE字符串、一个DATETIME字符串、一个TIMESTAMP或以YYMMDD或YYYYMMDD格式的本地时间的一个数字。1234mysql&gt; select UNIX_TIMESTAMP(); -&gt; 882226357 mysql&gt; select UNIX_TIMESTAMP(&apos;1997-10-04 22:23:00&apos;); -&gt; 875996580 当UNIX_TIMESTAMP被用于一个TIMESTAMP列，函数将直接接受值，没有隐含的“string-to-unix-timestamp”变换。 FROM_UNIXTIME(unix_timestamp)以’YYYY-MM-DD HH:MM:SS’或YYYYMMDDHHMMSS格式返回unix_timestamp参数所表示的值，取决于函数是在一个字符串还是或数字上下文中被使用。1234mysql&gt; select FROM_UNIXTIME(875996580); -&gt; &apos;1997-10-04 22:23:00&apos; mysql&gt; select FROM_UNIXTIME(875996580) + 0; -&gt; 19971004222300 FROM_UNIXTIME(unix_timestamp,format)返回表示 Unix 时间标记的一个字符串，根据format字符串格式化。format可以包含与DATE_FORMAT()函数列出的条目同样的修饰符。12mysql&gt; select FROM_UNIXTIME(UNIX_TIMESTAMP(), &apos;%Y %D %M %h:%i:%s %x&apos;); -&gt; &apos;1997 23rd December 03:43:30 x&apos; SEC_TO_TIME(seconds)返回seconds参数，变换成小时、分钟和秒，值以’HH:MM:SS’或HHMMSS格式化，取决于函数是在一个字符串还是在数字上下文中被使用。1234mysql&gt; select SEC_TO_TIME(2378); -&gt; &apos;00:39:38&apos; mysql&gt; select SEC_TO_TIME(2378) + 0; -&gt; 3938 TIME_TO_SEC(time)返回time参数，转换成秒。1234mysql&gt; select TIME_TO_SEC(&apos;22:23:00&apos;); -&gt; 80580 mysql&gt; select TIME_TO_SEC(&apos;00:39:38&apos;); -&gt; 2378 Mysql取系统函数：Select curtime();Select curdate():Select sysdate():select now();一、 控制流程函数a) CASE WHEN THEN 函数1语法： CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ……] [ELSE result ] END CASE WHEN [condition] THEN result [WHEN[condition] THEN result ……] [ELSE result] END ； 函数用法说明：在第一个方案的返回结果中， value =compare-value 。而第二个方案的返回结果是第一种情况的真实结果。如果没有匹配的结果值，则返回结果为 ELSE 后的结果，如果没有 ELSE 部分，则返回值为 NULL b) IF 函数用法1语法： IF(expr1,expr2,expr3) 函数用法说明：如果 expr1 是 TRUE (expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL) ，则 IF() 的返回值为 expr2 ; 否则返回值则为 expr3 。 IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定 c) IFNULL 函数1语法： IFNULL(expr1,expr2) 函数用法说明：假如 expr1 不为 NULL ，则 IFNULL() 的返回值为 expr1 ; 否则其返回值为 expr2 。 IFNULL() 的返回值是数字或是字符串，具体情况取决于其所使用的语境 二、 字符串比较函数a) 函数 ascii(str) 函数用法说明：返回值为字符串 str 的最左字符的数值。假如 str 为空字符串，则返回值为 0 。假如 str 为 NULL ，则返回值为 NULL 。 ASCII() 用于带有从 0 到 255 的数值的字符 b) 函数 BIN(N) 函数用法说明：返回值为 N 的二进制值的字符串表示，其中 N 为一个 longlong (BIGINT) 数字。这等同于 CONV(N ,10,2) 。假如 N 为 NULL ，则返回值为 NULL 。 c) 函数CHAR(N ,… [USING charset ]) 函数用法说明： CHAR() 将每个参数 N 理解为一个整数，其返回值为一个包含这些整数的代码值所给出的字符的字符串。 NULL 值被省略。 d) 函数CHAR_LENGTH(str ) 函数使用说明：返回值为字符串 str 的长度，长度的单位为字符。一个多字节字符算作一个单字符。对于一个 包含五个二字节字符集 , LENGTH() 返回值为 10, 而 CHAR_LENGTH() 的返回值为 5 e) 函数 CHARACTER_LENGTH(str ) 函数使用说明： CHARACTER_LENGTH() 是 CHAR_LENGTH() 的同义词。 f) 函数 COMPRESS(string_to_compress ) 函数使用说明： COMPRESS( 压缩一个字符串。这个函数要求 MySQL 已经用一个诸如 zlib 的压缩库压缩过。 否则，返回值始终是 NULL 。 UNCOMPRESS() 可将压缩过的字符串进行解压缩 ) 。 g) 函数 CONCAT(str1 ,str2 ,…) 函数使用说明：返回结果为连接参数产生的字符串。如有任何一个参数为 NULL ，则返回值为 NULL 。或许有一个或多个参数。 如果所有参数均为非二进制字符串，则结果为非二进制字符串。 如果自变量中含有任一二进制字符串，则结果为一个二进制字符串。一个数字参数被转化为与之相等的二进制字符串格式；若要避免这种情况，可使用显式类型 cast, 例如： SELECT CONCAT(CAST(int_col AS CHAR), char_col) h) 函数 CONCAT_WS(separator ,str1 ,str2 ,…) 函数使用说明： CONCAT_WS() 代表 CONCAT With Separator ，是 CONCAT() 的特殊形式。第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。如果分隔符为 NULL ，则结果为 NULL 。函数会忽略任何分隔符参数后的 NULL 值。 i) 函数CONV(N from_base, to_base) 函数使用说明：不同数基间转换数字。返回值为数字的 N 字符串表示，由 from_base 基转化为 to_base 基。如有任意一个参数为 NULL ，则返回值为 NULL 。自变量 N 被理解为一个整数，但是可以被指定为一个整数或字符串。最小基数为 2 ，而最大基数则为 36 。 If to_base 是一个负数，则 N 被看作一个带符号数。否则， N 被看作无符号数。 CONV() 的运行精确度为64 比特。 j) 函数 ELT(N ,str1 ,str2 ,str3 ,…) 函数使用说明：若 N = 1 ，则返回值为 str1 ，若 N = 2 ，则返回值为 str2 ，以此类推。若 N 小于 1 或大于参数的数目，则返回值为 NULL 。 ELT() 是 FIELD() 的补数 k) 函数 EXPORT_SET(bits ,on ,off [,separator [,number_of_bits ]]) 函数使用说明： 返回值为一个字符串，其中对于 bits 值中的每个位组，可以得到一个 on 字符串，而对于每个清零比特位，可以得到一个 off 字符串。 bits 中的比特值按照从右到左的顺序接受检验 ( 由低位比特到高位比特 ) 。字符串被分隔字符串分开 ( 默认为逗号‘,’) ，按照从左到右的顺序被添加到结果中。 number_of_bits 会给出被检验的二进制位数 ( 默认为 64) 。 l) 函数 FIELD(str, str1, str2, str3, ……) 函数使用说明：返回值为 str1 , str2 , str3 ,…… 列表中的 str 指数。在找不到 str 的情况下，返回值为 0 。如果所有对于 FIELD() 的参数均为字符串，则所有参数均按照字符串进行比较。如果所有的参数均为数字，则按照数字进行比较。否则，参数按照双倍进行比较。如果 str 为 NULL ，则返回值为 0 ，原因是 NULL 不能同任何值进行同等比较。 FIELD() 是 ELT() 的补数。 m) 函数FIND_IN_SET(str, strlist) 函数使用说明： 假如字符串 str 在由 N 子链组成的字符串列表 strlist 中，则返回值的范围在 1 到 N 之间 。一个字符串列表就是一个由一些被 ‘,’ 符号分开的自链组成的字符串。如果第一个参数是一个常数字符串，而第二个是 type SET 列，则 FIND_IN_SET()函数被优化，使用比特计算。如果 str 不在 strlist 或 strlist 为空字符串，则返回值为 0 。如任意一个参数为 NULL ，则返回值为 NULL 。 这个函数在第一个参数包含一个逗号 (‘,’) 时将无法正常运行。 n) 函数 FORMAT(X ,D ) 函数使用说明： 将 number X 设置为格式 ‘#,###,###.##’, 以四舍五入的方式保留到小数点后 D 位 , 而返回结果为一个字符串。 o) 函数 HEX(N_or_S ) 函数使用说明：如果N_OR_S 是一个数字，则返回一个 十六进制值 N 的 字符串表示，在这里， N 是一个longlong (BIGINT) 数。这相当于 CONV(N,10,16) 。如果N_OR_S 是一个字符串，则返回值为一个N_OR_S 的十六进制字符串表示，其中每个N_OR_S 里的每个字符被转化为两个十六进制数字。 p) 函数INSTR(str,substr) 函数使用说明：返回字符串 str 中子字符串的第一个出现位置。这和LOCATE() 的双参数形式相同，除非参数的顺序被颠倒。 q) 函数LCASE(str) 函数使用说明：LCASE() 是 LOWER() 的同义词 r) 函数LEFT(str,len) 函数使用说明：返回从字符串str 开始的len 最左字符 s) 函数 LENGTH(str ) 函数使用说明： 返回值为字符串 str 的长度，单位为字节。一个多字节字符算作多字节。这意味着 对于一个包含 5 个 2 字节字符的字符串， LENGTH() 的返回值为 10, 而CHAR_LENGTH() 的返回值则为5 。 t) 函数 LOAD_FILE(file_name) 函数使用说明：读取文件并将这一文件按照字符串的格式返回。 文件的位置必须在服务器上 , 你必须为文件制定路径全名，而且你还必须拥有 FILE 特许权。文件必须可读取，文件容量必须小于 max_allowed_packet 字节。若文件不存在，或因不满足上述条件而不能被读取， 则函数返回值为 NULL u) 函数 LOCATE(substr ,str ) , LOCATE(substr ,str ,pos ) 函数使用说明：第一个语法返回字符串 str 中子字符串substr 的第一个出现位置。第二个语法返回字符串 str 中子字符串substr 的第一个出现位置, 起始位置在pos 。如若substr 不在str中，则返回值为0 。 v) 函数LOWER(str ) 函数使用说明：返回字符串 str 以及所有根据最新的字符集映射表变为小写字母的字符 w) 函数LPAD(str ,len ,padstr ) 函数使用说明：返回字符串 str , 其左边由字符串padstr 填补到len 字符长度。假如str 的长度大于len , 则返回值被缩短至 len 字符。 x) 函数LTRIM(str ) 函数使用说明：返回字符串 str ，其引导空格字符被删除。 y) 函数 MAKE_SET(bits ,str1 ,str2 ,…) 函数使用说明： 返回一个设定值 ( 一个包含被 ‘,’ 号分开的字字符串的字符串 ) ，由在 bits 组中具有相应的比特的字符串组成。 str1 对应比特 0, str2 对应比特 1, 以此类推。 str1 , str2 , … 中的 NULL 值不会被添加到结果中。 z) 函数 MID(str ,pos ,len ) 函数使用说明： MID(str ,pos ,len ) 是 SUBSTRING(str ,pos ,len ) 的同义词。 aa) 函数 OCT(N ) 函数使用说明：返回一个 N 的八进制值的字符串表示，其中 N 是一个 longlong (BIGINT) 数。这等同于 CONV(N,10,8) 。若 N 为 NULL ，则返回值为 NULL 。 bb) 函数 OCTET_LENGTH(str ) 函数使用说明： OCTET_LENGTH() 是 LENGTH() 的同义词。 cc) 函数ORD(str ) 函数使用说明：若字符串str 的最左字符是一个多字节字符，则返回该字符的代码， 代码的计算通过使用以下公式计算其组成字节的数值而得出:(1st byte code)(2nd byte code × 256)(3rd byte code × 2562) …假如最左字符不是一个多字节字符，那么 ORD() 和函数ASCII() 返回相同的值 dd) 函数 POSITION(substr IN str ) 函数使用说明：POSITION(substr IN str ) 是 LOCATE(substr ,str ) 同义词 ee) 函数QUOTE(str ) 函数使用说明：引证一个字符串，由此产生一个在SQL 语句中可用作完全转义数据值的结果。 返回的字符串由单引号标注，每例都带有单引号 (‘’’) 、 反斜线符号 (‘\\’) 、 ASCII NUL以及前面有反斜线符号的Control-Z 。如果自变量的值为NULL, 则返回不带单引号的单词 “NULL” 。 ff) 函数REPEAT(str ,count ) 函数使用说明：返回一个由重复的字符串str 组成的字符串，字符串str 的数目等于count 。 若 count &lt;= 0, 则返回一个空字符串。若str 或 count 为 NULL ，则返回 NULL 。 gg) 函数REPLACE(str ,from_str ,to_str ) 函数使用说明：返回字符串str 以及所有被字符串to_str 替代的字符串from_str 。 hh) 函数REVERSE(str ) 函数使用说明：返回字符串 str ，顺序和字符顺序相反。 ii) 函数RIGHT(str ,len ) 函数使用说明：从字符串str 开始，返回最右len 字符。 jj) 函数RPAD(str ,len ,padstr ) 函数使用说明：返回字符串str , 其右边被字符串 padstr 填补至len 字符长度。假如字符串str 的长度大于 len , 则返回值被缩短到与 len 字符相同长度 kk) 函数RTRIM(str ) 函数使用说明：返回字符串 str ，结尾空格字符被删去。 ll) 函数 SOUNDEX(str ) 函数使用说明：从str 返回一个soundex 字符串。 两个具有几乎同样探测的字符串应该具有同样的 soundex 字符串。一个标准的soundex 字符串的长度为4 个字符，然而SOUNDEX() 函数会返回一个人以长度的字符串。 可使用结果中的SUBSTRING() 来得到一个标准 soundex 字符串。在str 中， 会忽略所有未按照字母顺序排列的字符。所有不在A-Z 范围之内的国际字母符号被视为元音字母。 mm) 函数expr1 SOUNDS LIKE expr2 函数使用说明： 这相当于SOUNDEX(expr1 ) = SOUNDEX(expr2 ) 。 nn) 函数SPACE(N ) 函数使用说明：返回一个由N 间隔符号组成的字符串 oo) 函数SUBSTRING(str ,pos ) , SUBSTRING(str FROM pos ) SUBSTRING(str ,pos ,len ) , SUBSTRING(str FROM pos FOR len ) 函数使用说明：不带有len 参数的格式从字符串str 返回一个子字符串，起始于位置 pos 。带有len 参数的格式从字符串str 返回一个长度同len 字符相同的子字符串，起始于位置 pos 。 使用FROM 的格式为标准 SQL 语法。也可能对pos 使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的pos 字符，而不是字符串的开头位置。在以下格式的函数中可以对pos 使用一个负值。 pp) 函数SUBSTRING_INDEX(str ,delim ,count ) 函数使用说明：在定界符 delim 以及count 出现前，从字符串str 返回自字符串。若count 为正值, 则返回最终定界符( 从左边开始) 左边的一切内容。若count 为负值，则返回定界符（从右边开始）右边的一切内容。 qq) 函数 TRIM([{BOTH | LEADING | TRAILING} [remstr ] FROM] str ) TRIM(remstr FROM] str ) 函数使用说明：返回字符串 str ， 其中所有remstr 前缀和/ 或后缀都已被删除。若分类符BOTH 、LEADIN 或TRAILING 中没有一个是给定的, 则假设为BOTH 。 remstr 为可选项，在未指定情况下，可删除空格 rr) 函数UCASE(str) 函数使用说明：UCASE() 是UPPER() 的同义词 ss) 函数UNCOMPRESS(string_to_uncompress ) 函数使用说明：对经COMPRESS() 函数压缩后的字符串进行解压缩。若参数为压缩值，则结果为 NULL 。这个函数要求 MySQL 已被诸如zlib 之类的压缩库编译过。否则, 返回值将始终是NULL tt) 函数 UNCOMPRESSED_LENGTH(compressed_string ) 函数使用说明： 返回压缩字符串压缩前的长度。 uu) 函数 UNHEX(str) 函数使用说明：执行从 HEX(str ) 的反向操作。就是说，它将参数中的每一对十六进制数字理解为一个数字，并将其转化为该数字代表的字符。结果字符以二进制字符串的形式返回 vv) 函数 UPPER(str ) 函数使用说明：返回字符串 str ， 以及根据最新字符集映射转化为大写字母的字符 三、 数学函数a) 函数 ABS(X) 函数使用说明：返回 X 的绝对值 b) 函数 ACOS(X ) 函数使用说明：返回 X 反余弦 , 即 , 余弦是 X 的值。若 X 不在 -1 到 1 的范围之内，则返回 NULL 。 c) 函数 ASIN （ X ） 函数使用说明：返回X 的反正弦，即，正弦为X 的值。若X 若X 不在-1 到 1 的范围之内，则返回 NULL 。 d) 函数ATAN(X ) 函数使用说明：返回 X 的反正切，即，正切为 X 的值。 e) 函数 ATAN(Y ,X ) , ATAN2(Y ,X ) 函数使用说明：返回两个变量 X 及 Y 的反正切。 它类似于 Y 或 X 的反正切计算 , 除非两个参数的符号均用于确定结果所在象限。 f) 函数 CEILING(X ) CEIL(X ) 函数使用说明：返回不小于 X 的最小整数值。 g) 函数 COS(X ) 函数使用说明：返回 X 的余弦，其中 X 在弧度上已知。 h) 函数 COT(X ) 函数使用说明：返回 X 的余切 i) 函数 CRC32(expr ) 函数使用说明：计算循环冗余码校验值并返回一个 32 比特无符号值。若参数为 NULL ，则结果为 NULL 。该参数应为一个字符串，而且在不是字符串的情况下会被作为字符串处理（若有可能） j) 函数 DEGREES(X ) 函数使用说明：返回参数 X , 该参数由弧度被转化为度。 k) 函数 EXP(X ) 函数使用说明：返回 e 的 X 乘方后的值 ( 自然对数的底 ) 。 l) 函数 FLOOR(X ) 函数使用说明：返回不大于 X 的最大整数值 。 m) 函数 FORMAT(X ,D ) 函数使用说明：将数字 X 的格式写成 ‘#,###,###.##’ 格式 , 即保留小数点后 D 位，而第 D 位的保留方式为四舍五入，然后将结果以字符串的形式返回 n) 函数 LN(X ) 函数使用说明：返回 X 的自然对数 , 即 , X 相对于基数 e 的对数 o) 函数 LOG(X ) LOG(B ,X ) 函数使用说明：若用一个参数调用，这个函数就会返回 X 的自然对数。 p) 函数 LOG2(X ) 函数使用说明：返回 X 的基数为 2 的对数。 q) 函数 LOG10(X ) 函数使用说明：返回 X 的基数为 10 的对数。 r) 函数 MOD(N ,M ) , N % M N MOD M 函数使用说明： 模操作。返回 N 被 M 除后的余数。 s) 函数 PI() 函数使用说明：返回 ϖ (pi) 的值。默认的显示小数位数是 7 位 , 然而 MySQL 内部会使用完全双精度值。 t) 函数 POW(X ,Y ) , POWER(X ,Y ) 函数使用说明：返回 X 的 Y 乘方的结果值。 u) 函数 RADIANS(X ) 函数使用说明：返回由度转化为弧度的参数 X , ( 注意 ϖ 弧度等于 180 度）。 v) 函数 RAND() RAND(N ) 函数使用说明：返回一个随机浮点值 v ，范围在 0 到 1 之间 ( 即 , 其范围为 0 ≤ v ≤ 1.0) 。若已指定一个整数参数 N ，则它被用作种子值，用来产生重复序列。 w) 函数 ROUND(X ) ROUND(X ,D ) 函数使用说明：返回参数 X , 其值接近于最近似的整数。在有两个参数的情况下，返回 X ，其值保留到小数点后 D 位，而第 D 位的保留方式为四舍五入。若要接保留 X 值小数点左边的 D位，可将 D 设为负值。 x) 函数 SIGN(X ) 函数使用说明：返回参数作为 -1 、 0 或 1 的符号，该符号取决于 X 的值为负、零或正。 y) 函数 SIN(X ) 函数使用说明：返回 X 正弦，其中 X 在弧度中被给定。 z) 函数 SQRT(X ) 函数使用说明： 返回非负数 X 的二次方根。 aa) 函数TAN(X ) 函数使用说明： 返回 X 的正切，其中 X 在弧度中被给定。 bb) 函数TRUNCATE(X ,D ) 函数使用说明： 返回被舍去至小数点后 D 位的数字 X 。若 D 的值为 0, 则结果不带有小数点或不带有小数部分。可以将 D 设为负数 , 若要截去 ( 归零 ) X 小数点左起第 D 位开始后面所有低位的值 四、 日期和时间函数a) 函数ADDDATE(date ,INTERVAL expr type ) ADDDATE(expr ,days ) 函数使用说明： 当被第二个参数的 INTERVAL 格式激活后， ADDDATE() 就是 DATE_ADD() 的同义词。相关函数 SUBDATE() 则是 DATE_SUB() 的同义词。对于 INTERVAL 参数上的信息 ，请参见关于 DATE_ADD() 的论述。 b) 函数 ADDTIME(expr ,expr2 ) 函数使用说明： ADDTIME() 将 expr2 添加至 expr 然后返回结果。 expr 是一个时间或时间日期表达式，而 expr2 是一个时间表达式。 c) 函数 CONVERT_TZ(dt ,from_tz ,to_tz ) 函数使用说明： CONVERT_TZ() 将时间日期值 dt 从 from_tz 给出的时区转到 to_tz 给出的时区，然后返回结果值。关于可能指定的时区的详细论述，若自变量无效，则这个函数会返回NULL d) 函数 CURDATE() 函数使用说明：将当前日期按照 ‘YYYY-MM-DD’ 或 YYYYMMDD 格式的值返回，具体格式根据函数用在字符串或是数字语境中而定。 e) 函数 CURRENT_DATE CURRENT_DATE() 函数使用说明： CURRENT_DATE 和 CURRENT_DATE() 是的同义词 . f) 函数 CURTIME() 函数使用说明： 将当前时间以 ‘HH:MM:SS’ 或 HHMMSS 的格式返回， 具体格式根据函数用在字符串或是数字语境中而定。 g) 函数 CURRENT_TIME, CURRENT_TIME() 函数使用说明： CURRENT_TIME 和 CURRENT_TIME() 是 CURTIME() 的同义词。 h) 函数 CURRENT_TIMESTAMP, CURRENT_TIMESTAMP() 函数使用说明： CURRENT_TIMESTAMP 和 CURRENT_TIMESTAMP() 是 NOW() 的同义词 i) 函数 DATE(expr ) 函数使用说明： 提取日期或时间日期表达式 expr 中的日期部分。 j) 函数 DATEDIFF(expr ,expr2 ) 函数使用说明： DATEDIFF() 返回起始时间 expr 和结束时间 expr2 之间的天数。 Expr 和 expr2 为日期或 date-and-time 表达式。计算中只用到这些值的日期部分。 k) 函数 DATE_ADD(date ,INTERVAL expr type ) DATE_SUB(date ,INTERVAL expr type ) 函数使用说明：这些函数执行日期运算。 date 是一个 DATETIME 或 DATE 值，用来指定起始时间。 expr 是一个表达式，用来指定从起始日期添加或减去的时间间隔值。 Expr 是一个字符串 ; 对于负值的时间间隔，它可以以一个 ‘-’ 开头。 type 为关键词，它指示了表达式被解释的方式。 l) 函数 DATE_FORMAT(date ,format ) 函数使用说明：根据 format 字符串安排 date 值的格式。 m) 函数 DAY(date ) 函数使用说明： DAY() 和 DAYOFMONTH() 的意义相同 n) 函数 DAYNAME(date ) 函数使用说明：返回 date 对应的工作日名称。 o) 函数 DAYOFMONTH(date ) 函数使用说明：返回 date 对应的该月日期，范围是从 1 到 31 p) 函数 DAYOFWEEK(date ) 函数使用说明：返回 date (1 = 周日 , 2 = 周一 , …, 7 = 周六 ) 对应的工作日索引。这些索引值符合 ODBC 标准 q) 函数 DAYOFYEAR(date ) 函数使用说明：返回date 对应的一年中的天数，范围是从 1 到366 。 r) 函数 EXTRACT(type FROM date ) 函数使用说明： EXTRACT() 函数所使用的时间间隔类型说明符同 DATE_ADD() 或 DATE_SUB() 的相同 , 但它从日期中提取其部分，而不是执行日期运算。 s) 函数FROM_DAYS(N ) 函数使用说明： 给定一个天数 N , 返回一个 DATE 值。 t) 函数 FROM_UNIXTIME(unix_timestamp )ROM_UNIXTIME(unix_timestamp ,format ) 函数使用说明：返回’YYYY-MM-DD HH:MM:SS’ 或YYYYMMDDHHMMSS 格式值的unix_timestamp 参数表示，具体格式取决于该函数是否用在字符串中或是数字语境中。 若format 已经给出，则结果的格式是根据format 字符串而定。 format 可以包含同DATE_FORMAT() 函数输入项列表中相同的说明符。 u) 函数 GET_FORMAT(DATE|TIME|DATETIME, ‘EUR’|’USA’|’JIS’|’ISO’|’INTERNAL’) 函数使用说明：返回一个格式字符串。这个函数在同 DATE_FORMAT() 及 STR_TO_DATE() 函数结合时很有用 v) 函数 HOUR(time ) 函数使用说明：返回 time 对应的小时数。对于日时值的返回值范围是从 0 到 23 w) 函数 LAST_DAY(date ) 函数使用说明：获取一个日期或日期时间值，返回该月最后一天对应的值。若参数无效，则返回 NULL 。 x) 函数 LOCALTIME, LOCALTIME() 函数使用说明： LOCALTIME 及 LOCALTIME() 和 NOW() 具有相同意义。 y) 函数 LOCALTIMESTAMP, LOCALTIMESTAMP() 函数使用说明： LOCALTIMESTAMP 和 LOCALTIMESTAMP() 和 NOW() 具有相同意义。 z) 函数 MAKEDATE(year ,dayofyear ) 函数使用说明：给出年份值和一年中的天数值，返回一个日期。 dayofyear 必须大于 0 ，否则结果为 NULL 。 aa) 函数 MAKETIME(hour ,minute ,second ) 函数使用说明： 返回由 hour 、 minute 和 second 参数计算得出的时间值 bb) 函数 CROSECOND(expr ) 函数使用说明：从时间或日期时间表达式 expr 返回微秒值，其数字范围从 0 到 999999 。 cc) 函数 MINUTE(time ) 函数使用说明：返回 time 对应的分钟数 , 范围是从 0 到 59 。 dd) 函数 MONTH(date ) 函数使用说明：返回 date 对应的月份，范围时从 1 到 12 。 ee) 函数 MONTHNAME(date ) 函数使用说明： 返回 date 对应月份的全名 ff) 函数 NOW() 函数使用说明：返回当前日期和时间值，其格式为 ‘YYYY-MM-DD HH:MM:SS’ 或 YYYYMMDDHHMMSS ， 具体格式取决于该函数是否用在字符串中或数字语境中。 gg) 函数 PERIOD_ADD(P ,N ) 函数使用说明：添加 N 个月至周期 P ( 格式为 YYMM 或 YYYYMM) ，返回值的格式为 YYYYMM 。注意周期参数 P 不是 日期值。 hh) 函数 PERIOD_DIFF(P1 ,P2 ) 函数使用说明：返回周期 P1 和 P2 之间的月份数。 P1 和 P2 的格式应该为 YYMM 或 YYYYMM 。注意周期参数 P1 和 P2 不是 日期值。 ii) 函数 QUARTER(date ) 函数使用说明：返回 date 对应的一年中的季度值，范围是从 1 到 4 jj) 函数 SECOND(time ) 函数使用说明：返回 time 对应的秒数 , 范围是从 0 到 59 。 kk) 函数 SEC_TO_TIME(seconds ) 函数使用说明： 返回被转化为小时、 分钟和秒数的 seconds 参数值 , 其格式为 ‘HH:MM:SS’ 或 HHMMSS ，具体格式根据该函数是否用在字符串或数字语境中而定 ll) 函数 STR_TO_DATE(str ,format ) 函数使用说明：这是 DATE_FORMAT() 函数的倒转。它获取一个字符串 str 和一个格式字符串 format 。若格式字符串包含日期和时间部分，则 STR_TO_DATE() 返回一个 DATETIME值， 若该字符串只包含日期部分或时间部分，则返回一个 DATE 或 TIME 值。 mm) 函数 SUBDATE(date ,INTERVAL expr type ) SUBDATE(expr ,days ) 函数使用说明：当被第二个参数的 INTERVAL 型式调用时 , SUBDATE() 和 DATE_SUB() 的意义相同。对于有关 INTERVAL 参数的信息， 见有关 DATE_ADD() 的讨论。 nn) 函数 SUBTIME(expr ,expr2 ) 函数使用说明： SUBTIME() 从 expr 中提取 expr2 ，然后返回结果。 expr 是一个时间或日期时间表达式，而 xpr2 是一个时间表达式。 oo) 函数 SYSDATE() 函数使用说明：返回当前日期和时间值，格式为 ‘YYYY-MM-DD HH:MM:SS’ 或 YYYYMMDDHHMMSS ， 具体格式根据函数是否用在字符串或数字语境而定。 pp) 函数 TIME(expr ) 函数使用说明：提取一个时间或日期时间表达式的时间部分，并将其以字符串形式返回。 qq) 函数 TIMEDIFF(expr ,expr2 ) 函数使用说明： TIMEDIFF() 返回起始时间 expr 和结束时间 expr2 之间的时间。 expr 和 expr2 为时间或 date-and-time 表达式 , 两个的类型必须一样。 rr) 函数TIMESTAMP(expr ) , TIMESTAMP(expr ,expr2 ) 函数使用说明： 对于一个单参数 , 该函数将日期或日期时间表达式 expr 作为日期时间值返回 . 对于两个参数 , 它将时间表达式 expr2 添加到日期或日期时间表达式 expr 中，将 theresult作为日期时间值返回。 ss) 函数 TIMESTAMPADD(interval ,int_expr ,datetime_expr ) 函数使用说明：将整型表达式int_expr 添加到日期或日期时间表达式 datetime_expr 中。 int_expr 的单位被时间间隔参数给定，该参数必须是以下值的其中一个： FRAC_SECOND、SECOND 、 MINUTE 、 HOUR 、 DAY 、 WEEK 、 MONTH 、 QUARTER 或 YEAR 。可使用所显示的关键词指定Interval 值，或使用SQL_TSI_ 前缀。例如, DAY 或SQL_TSI_DAY都是正确的 tt) 函数 TIMESTAMPDIFF(interval ,datetime_expr1 ,datetime_expr2 ) 函数使用说明：返回日期或日期时间表达式 datetime_expr1 和 datetime_expr2 the 之间的整数差。其结果的单位由 interval 参数给出。 interval 的法定值同 TIMESTAMPADD() 函数说明中所列出的相同。 uu) 函数 TIME_FORMAT(time ,format ) 函数使用说明：其使用和 DATE_FORMAT() 函数相同 , 然而 format 字符串可能仅会包含处理小时、分钟和秒的格式说明符。其它说明符产生一个 NULL 值或 0 。 vv) 函数 TIME_TO_SEC(time ) 函数使用说明：返回已转化为秒的 time 参数 ww) 函数 TO_DAYS(date ) 函数使用说明：给定一个日期 date , 返回一个天数 ( 从年份 0 开始的天数 ) 。 xx) 函数 UNIX_TIMESTAMP(), UNIX_TIMESTAMP(date ) 函数使用说明：若无参数调用，则返回一个 Unix timestamp (‘1970-01-01 00:00:00’ GMT 之后的秒数 ) 作为无符号整数。若用 date 来调用 UNIX_TIMESTAMP() ，它会将参数值以’1970-01-01 00:00:00’ GMT 后的秒数的形式返回。 date 可以是一个 DATE 字符串、一个 DATETIME 字符串、一个 TIMESTAMP 或一个当地时间的 YYMMDD 或 YYYMMDD 格式的数字。 yy) 函数 UTC_DATE, UTC_DATE() 函数使用说明：返回当前 UTC 日期值，其格式为 ‘YYYY-MM-DD’ 或 YYYYMMDD ，具体格式取决于函数是否用在字符串或数字语境中。 zz) 函数 UTC_TIME, UTC_TIME() 函数使用说明：返回当前 UTC 值，其格式为 ‘HH:MM:SS’ 或 HHMMSS ，具体格式根据该函数是否用在字符串或数字语境而定。 aaa) 函数 UTC_TIMESTAMP, UTC_TIMESTAMP() 函数使用说明：返回当前 UTC 日期及时间值，格式为 ‘YYYY-MM-DD HH:MM:SS’ 或 YYYYMMDDHHMMSS ，具体格式根据该函数是否用在字符串或数字语境而定 bbb) 函数 WEEK(date [,mode ]) 函数使用说明：该函数返回 date 对应的星期数。 WEEK() 的双参数形式允许你指定该星期是否起始于周日或周一， 以及返回值的范围是否为从 0 到 53 或从 1 到 53 。若 mode 参数被省略，则使用 default_week_format 系统自变量的值。 ccc) 函数 WEEKDAY(date ) 函数使用说明：返回 date (0 = 周一 , 1 = 周二 , … 6 = 周日 ) 对应的工作日索引 weekday index for ddd) 函数 WEEKOFYEAR(date ) 函数使用说明：将该日期的阳历周以数字形式返回，范围是从 1 到 53 。它是一个兼容度函数，相当于 WEEK(date ,3) 。 eee) 函数 YEAR(date ) 函数使用说明：返回 date 对应的年份 , 范围是从 1000 到 9999 。 fff) 函数 YEARWEEK(date ), YEARWEEK(date ,start ) 函数使用说明：返回一个日期对应的年或周。 start 参数的工作同 start 参数对 WEEK() 的工作相同。结果中的年份可以和该年的第一周和最后一周对应的日期参数有所不同。 五、 全文搜索功能函数a) 函数 MATCH (col1,col2,…) AGAINST (expr [IN BOOLEAN MODE | WITH QUERY EXPANSION])六、 加密函数a) 函数 AES_ENCRYPT(str ,key_str ) , AES_DECRYPT(crypt_str ,key_str ) 函数使用说明：这些函数允许使用官方 AES 进行加密和数据加密 ( 高级加密标准 ) 算法 , 即以前人们所熟知的 “Rijndael” 。 保密关键字的长度为 128 比特，不过你可以通过改变源而将其延长到 256 比特。我们选择了 128 比特的原因是它的速度要快得多，且对于大多数用途而言这个保密程度已经够用。 b) 函数DECODE(crypt_str ,pass_str ) 函数使用说明：使用 pass_str 作为密码，解密加密字符串 crypt_str ， crypt_str 应该是由 ENCODE() 返回的字符串。 c) 函数 ENCODE(str ,pass_str ) 函数使用说明：使用 pass_str 作为密码，解密 str 。 使用 DECODE() 解密结果。 d) 函数 DES_DECRYPT(crypt_str [,key_str ]) 函数使用说明：使用 DES_ENCRYPT() 加密一个字符串。若出现错误，这个函数会返回 NULL 。 e) 函数 DES_ENCRYPT(str [,(key_num |key_str )]) 函数使用说明：用 Triple-DES 算法给出的关键字加密字符串。若出现错误，这个函数会返回 NULL 。 f) 函数 ENCRYPT(str [,salt ]) 函数使用说明：使用 Unix crypt() 系统调用加密 str 。 salt 参数应为一个至少包含 2 个字符的字符串。若没有给出 salt 参数，则使用任意值。 g) 函数 MD5(str ) 函数使用说明：为字符串算出一个 MD5 128 比特检查和。该值以 32 位十六进制数字的二进制字符串的形式返回 , 若参数为 NULL 则会返回 NULL 。例如，返回值可被用作散列关键字 h) 函数 OLD_PASSWORD(str ) 函数使用说明：当 PASSWORD() 的执行变为改善安全性时， OLD_PASSWORD() 会被添加到 MySQL 。 OLD_PASSWORD() 返回从前的 PASSWORD() 执行值 ( 4.1 之前 ) ，同时允许你为任何 4.1 之前的需要连接到你的 5.1 版本 MySQL 服务器前客户端设置密码，从而不至于将它们切断 i) 函数PASSWORD(str ) 函数使用说明：从原文密码str 计算并返回密码字符串，当参数为 NULL 时返回 NULL 。这个函数用于用户授权表的Password 列中的加密MySQL 密码存储 七、 信息函数a) 函数 BENCHMARK(count ,expr ) 函数使用说明： BENCHMARK() 函数重复 count 次执行表达式 expr 。 它可以被用于计算 MySQL 处理表达式的速度。结果值通常为 0 。另一种用处来自 mysql 客户端内部 , 能够报告问询执行的次数 b) 函数 CHARSET(str ) 函数使用说明：返回字符串自变量的字符集。 c) 函数 COERCIBILITY(str ) 函数使用说明：返回字符串自变量的整序可压缩性值。 d) 函数 COLLATION(str ) 函数使用说明：返回惠字符串参数的排序方式。 e) 函数 CONNECTION_ID() 函数使用说明：返回对于连接的连接 ID ( 线程 ID) 。每个连接都有各自的唯一 ID 。 f) 函数 CURRENT_USER, CURRENT_USER() 函数使用说明：返回当前话路被验证的用户名和主机名组合。这个值符合确定你的存取权限的 MySQL 账户。在被指定 SQL SECURITY DEFINER 特征的存储程序内， CURRENT_USER() 返回程序的创建者 g) 函数 DATABASE() 函数使用说明：返回使用 utf8 字符集的默认 ( 当前 ) 数据库名。在存储程序里，默认数据库是同该程序向关联的数据库，但并不一定与调用语境的默认数据库相同。 h) 函数 FOUND_ROWS() 函数使用说明： A SELECT 语句可能包括一个 LIMIT 子句，用来限制服务器返回客户端的行数。在有些情况下，需要不用再次运行该语句而得知在没有 LIMIT 时到底该语句返回了多少行。为了知道这个行数 , 包括在 SELECT 语句中选择 SQL_CALC_FOUND_ROWS ，随后调用 FOUND_ROWS() i) 函数 LAST_INSERT_ID() LAST_INSERT_ID(expr ) 函数使用说明：自动返回最后一个 INSERT 或 UPDATE 问询为 AUTO_INCREMENT 列设置的第一个 发生的值。 j) 函数 ROW_COUNT() 函数使用说明： ROW_COUNT() 返回被前面语句升级的、插入的或删除的行数。 这个行数和 mysql 客户端显示的行数及 mysql_affected_rows() C API 函数返回的值相同。 k) 函数 SCHEMA() 函数使用说明：这个函数和 DATABASE() 具有相同的意义 l) 函数 SESSION_USER() 函数使用说明： SESSION_USER() 和 USER() 具有相同的意义。 m) 函数 SYSTEM_USER() 函数使用说明： SYSTEM_USER() 合 USER() 具有相同的意义 n) 函数 USER() 函数使用说明：返回当前 MySQL 用户名和机主名 o) 函数 VERSION() 函数使用说明：返回指示 MySQL 服务器版本的字符串。这个字符串使用 utf8 字符集。 八、 其他函数a) 函数 DEFAULT(col_name ) 函数使用说明：返回一个表列的默认值。若该列没有默认值则会产生错误。 b) 函数 FORMAT(X ,D ) 函数使用说明：将数字 X 的格式写为 ‘#,###,###.##’, 以四舍五入的方式保留小数点后 D 位， 并将结果以字符串的形式返回。若 D 为 0, 则返回结果不带有小数点，或不含小数部分。 c) 函数 GET_LOCK(str ,timeout ) 函数使用说明：设法使用字符串 str 给定的名字得到一个锁， 超时为 timeout 秒。若成功得到锁，则返回 1 ，若操作超时则返回 0 ( 例如 , 由于另一个客户端已提前封锁了这个名字 ), 若发生错误则返回 NULL ( 诸如缺乏记忆或线程 mysqladmin kill 被断开 ) 。假如你有一个用 GET_LOCK() 得到的锁，当你执行 RELEASE_LOCK() 或你的连接断开 ( 正常或非正常 ) 时，这个锁就会解除 d) 函数 INET_ATON(expr ) 函数使用说明：给出一个作为字符串的网络地址的点地址表示，返回一个代表该地址数值的整数。地址可以是 4 或 8 比特地址。 e) 函数 INET_NTOA(expr ) 函数使用说明：给定一个数字网络地址 (4 或 8 比特 ), 返回作为字符串的该地址的电地址表示 f) 函数 IS_FREE_LOCK(str ) 函数使用说明：检查名为 str 的锁是否可以使用 ( 换言之 , 没有被封锁 ) 。若锁可以使用，则返回 1 ( 没有人在用这个锁 ), 若这个锁正在被使用，则返回 0 ，出现错误则返回 NULL ( 诸如不正确的参数 ) 。 g) 函数 IS_USED_LOCK(str ) 函数使用说明：检查名为 str 的锁是否正在被使用 ( 换言之 , 被封锁 ) 。若被封锁，则返回使用该锁的客户端的连接标识符。否则返回 NULL 。 h) 函数 MASTER_POS_WAIT(log_name ,log_pos [,timeout ]) 函数使用说明：该函数对于控制主从同步很有用处。它会持续封锁，直到从设备阅读和应用主机记录中所有补充资料到指定的位置。返回值是其为到达指定位置而必须等待的记录事件的数目。若从设备 SQL 线程没有被启动、从设备主机信息尚未初始化、参数不正确或出现任何错误，则该函数返回 NULL 。若超时时间被超过，则返回 -1 。若在 MASTER_POS_WAIT() 等待期间，从设备 SQL 线程中止，则该函数返回 NULL 。若从设备由指定位置通过，则函数会立即返回结果。 i) 函数 NAME_CONST(name ,value ) 函数使用说明：返回给定值。 当用来产生一个结果集合列时 , NAME_CONST() 促使该列使用给定名称。 j) 函数 RELEASE_LOCK(str ) 函数使用说明：解开被 GET_LOCK() 获取的，用字符串 str 所命名的锁。若锁被解开，则返回 1 ，若改线程尚未创建锁，则返回 0 ( 此时锁没有被解开 ), 若命名的锁不存在，则返回 NULL。若该锁从未被对 GET_LOCK() 的调用获取，或锁已经被提前解开，则该锁不存在。 k) 函数 SLEEP(duration ) 函数使用说明：睡眠 ( 暂停 ) 时间为 duration 参数给定的秒数，然后返回 0 。若 SLEEP() 被中断 , 它会返回 1 。 duration 或许或包括一个给定的以微秒为单位的分数部分。 l) 函数 UUID() 函数使用说明：返回一个通用唯一标识符 (UUID) ， UUID 被设计成一个在时间和空间上都独一无二的数字。 2 个对 UUID() 的调用应产生 2 个不同的值，即使这些调用的执行是在两个互不相连的单独电脑上进行。 m) 函数 VALUES(col_name ) 函数使用说明：在一个 INSERT … ON DUPLICATE KEY UPDATE … 语句中，你可以在 UPDATE 子句中使用 VALUES(col_name ) 函数，用来访问来自该语句的 INSERT 部分的列值。换言之， UPDATE 子句中的 VALUES(col_name ) 访问需要被插入的 col_name 的值 , 并不会发生重复键冲突。这个函数在多行插入中特别有用。 VALUES() 函数只在 INSERT … UPDATE 语句中有意义，而在其它情况下只会返回 NULL 九、 聚合函数a) 函数 AVG([DISTINCT] expr ) 函数使用说明：返回 expr 的平均值。 DISTINCT 选项可用于返回 expr 的不同值的平均值。 b) 函数 BIT_AND(expr ) 函数使用说明：返回expr 中所有比特的 bitwise AND 。计算执行的精确度为64 比特(BIGINT) 。若找不到匹配的行，则这个函数返回18446744073709551615 。( 这是无符号 BIGINT值，所有比特被设置为 1 ）。 c) 函数 BIT_OR(expr ) 函数使用说明：返回expr 中所有比特的bitwise OR 。计算执行的精确度为64 比特(BIGINT) 。若找不到匹配的行，则函数返回 0 。 d) 函数BIT_XOR(expr ) 函数使用说明：返回expr 中所有比特的bitwise XOR 。计算执行的精确度为64 比特(BIGINT) 。若找不到匹配的行，则函数返回 0 。 e) 函数 COUNT(expr ) 函数使用说明：返回SELECT 语句检索到的行中非NULL 值的数目。若找不到匹配的行，则COUNT() 返回 0 f) 函数 COUNT(DISTINCT expr ,[expr …]) 函数使用说明：返回不同的非NULL 值数目。若找不到匹配的项，则COUNT(DISTINCT) 返回 0 g) 函数 GROUP_CONCAT(expr ) 函数使用说明：该函数返回带有来自一个组的连接的非NULL 值的字符串结果。其完整的语法如下所示： 1234GROUP_CONCAT([DISTINCT] expr [,expr ...][ORDER BY &#123;unsigned_integer | col_name | expr &#125;[ASC | DESC] [,col_name ...]][SEPARATOR str_val ]) h) 函数 MIN([DISTINCT] expr ), MAX([DISTINCT] expr ) 函数使用说明：返回 expr 的最小值和最大值。 MIN() 和 MAX() 的取值可以是一个字符串参数；在这些情况下， 它们返回最小或最大字符串值。 i) 函数 STD(expr ) STDDEV(expr ) 函数使用说明：返回 expr 的总体标准偏差。这是标准 SQL 的延伸。这个函数的 STDDEV() 形式用来提供和 Oracle 的兼容性。可使用标准 SQL 函数 STDDEV_POP() 进行代替 j) 函数 STDDEV_POP(expr ) 函数使用说明：返回expr 的总体标准偏差(VAR_POP() 的平方根) 。你也可以使用 STD() 或STDDEV(), 它们具有相同的意义，然而不是标准的 SQL 。若找不到匹配的行，则STDDEV_POP() 返回 NULL k) 函数 STDDEV_SAMP(expr ) 函数使用说明：返回expr 的样本标准差 ( VAR_SAMP() 的平方根) 。若找不到匹配的行，则STDDEV_SAMP() 返回 NULL l) 函数 SUM([DISTINCT] expr ) 函数使用说明：返回expr 的总数。 若返回集合中无任何行，则 SUM() 返回NULL 。DISTINCT 关键词可用于 MySQL 5.1 中，求得expr 不同值的总和。 若找不到匹配的行，则SUM() 返回NULL m) 函数 VAR_POP(expr ) 函数使用说明：返回 expr 总体标准方差。它将行视为总体，而不是一个样本， 所以它将行数作为分母。你也可以使用 VARIANCE(), 它具有相同的意义然而不是 标准的 SQL n) 函数 VAR_SAMP(expr ) 函数使用说明：返回expr 的样本方差。更确切的说，分母的数字是行数减去1 。若找不到匹配的行，则VAR_SAMP() 返回NULL o) 函数VARIANCE(expr ) 函数使用说明：返回expr 的总体标准方差。这是标准SQL 的延伸。可使用标准SQL 函数 VAR_POP() 进行代替。若找不到匹配的项，则VARIANCE() 返回NULL","path":"2018/09/13/ySql函数字典/","date":"09-13","excerpt":""},{"title":"Valet 安装使用详细教程","text":"简介Valet 是为 Mac 打造的极简开发环境，没有Vagrant，没有虚拟机，也无需配置 /etc/hosts 文件，还可以使用本地隧道公开分享你的站点。 启动 Mac 后，Laravel Valet 会在后台静默运行 Nginx，然后通过 DnsMasq，Valet 会代理所有针对 *.dev 域名的请求指向本地安装的站点目录。 此外，这样一个极速的 Laravel 开发环境只需要占用 7M 内存。Valet 并不是想要替代 Vagrant 或者 Homestead，只是提供了另外一种选择，更加灵活、极速、以及占用更小的内存空间。正是基于这些原因，我们将 Valet 称之为轻量级的开发环境。 Valet 开箱支持但不限于以下软件和工具： Laravel Lumen Bedrock CakePHP 3 Concrete5 Contao Craft Drupal Jigsaw Joomla Katana Kirby Magento OctoberCMS Sculpin Slim Statamic Static HTML Symfony WordPress Zend以上支持的驱动文件位于 ~/.composer/vendor/laravel/valet/cli/drivers 目录下，当然，你还可以通过自定义驱动扩展 Valet，自定义的驱动文件存放在 ~/.valet/Drivers 目录。 Valet 还是 Homestead正如我们上篇教程所介绍的，Laravel 还提供了另外一个开发环境 Homestead。Homestead 和 Valet 的不同之处在于两者的目标受众和本地开发方式。 Homestead 提供了一个完整的、包含自动化 Nginx 配置的 Ubuntu 虚拟机，如果你需要一个完整的虚拟化 Linux 开发环境或者使用的是 Windows/Linux 操作系统，那么 Homestead 无疑是最佳选择，此外，学院君以为如果是公司团队进行正规的工程化开发，还是使用 Homestead 为佳，原因我在上篇教程中以及提及。 Valet 官方默认只支持 Mac，并且要求本地另外安装 PHP 和数据库服务器，当然这可以通过 Homebrew 命令轻松实现（brew install php71 以及 brew install mysql），Valet 通过最小的资源消耗提供了一个极速的本地开发环境，如果你只需要 PHP/MySQL 并且不需要完整的虚拟化开发环境，那么 Valet 将是最好的选择，学院君建议如果是 Mac 环境本地尝鲜，所以尝鲜就是以学习为目的或者只是快速做个 Demo 原型，那 Valet 无疑是很棒的选择。 最后，建议归建议，Valet 和 Homestead 都是搭建本地 Laravel 开发环境的好工具，最终选择使用哪一个取决于你个人的喜好或团队的需求。 安装注：已安装的可直接跳到升级部分。 Valet 要求 Mac 操作系统和 Homebrew。安装之前，还要确保没有其他程序如Apache 或 Nginx 绑定到本地的80端口。安装步骤如下： 使用 brew update 安装或更新 Homebrew 到最新版本 通过 Homebrew 安装 PHP 7.1： brew install homebrew/php/php71 通过 Composer 安装 Valet： composer global require laravel/valet 运行 valet install 命令，这将会配置并安装 Valet 和 DnsMasq，然后注册 Valet 后台随机启动。 安装完 Valet 后，尝试使用命令如 ping foobar.dev 在终端 ping 一下任意 *.dev 域名，如果 Valet 安装正确就会看到来自 127.0.0.1 的响应： PING foobar.dev (127.0.0.1): 56 data bytes 64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.069 ms 64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.077 ms 64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.072 ms 64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.082 ms 每次系统启动的时候 Valet 会在后台自动启动，不需要再次手动运行 valet start 或 valet install。 使用其他域名 默认情况下，Valet 使用 .dev 域名后缀，如果你想要使用其他域名，可以使用 valet domain tld-name 命令。 例如，你想使用 .com 域名后缀取代 .dev，运行 valet domain com，Valet 将会自动将站点域名后缀改为 *.com： ￼ 数据库注：已安装 MySQL 数据库忽略本条。 如果你需要数据库，可以在命令行通过 brew install mysql 安装MySQL，安装完成后就可以通过 brew services start mysql 来启动它，然后通过用户名 root 和一个空密码连接到本地数据库。 升级你可以在终端使用 composer global update 命令来升级 Valet。升级之后，最好运行下 valet install 命令以便 Valet 在必要情况下对配置文件进行升级： ￼ 升级到 Valet 2.0注：先通过 valet –version 查看本机安装的 Valet 版本，如果版本已经大于 2.0 则可以跳过本段教程。 Valet 2.0 将 Valet 底层的 web 服务器从 Caddy 替换成了 Nginx，升级到这个版本之前需要运行以下命令来停止和卸载已经在后台运行的 Caddy： 12valet stopvalet uninstall 接下来，需要升级到最新版本的 Valet。基于 Valet 的安装方式，你可以通过 Git 或 Composer 来实现，如果你是通过 Composer 安装的 Valet，需要通过如下方式更新到最新的主版本： 1composer global require laravel/valet 最新的 Valet 源码下载好之后，运行 install 命令： 12valet installvalet restart 升级之后，需要 re-park 和 re-link 站点。 访问站点Valet 安装完成后，就可以启动服务站点，Valet 为此提供了两个命令：park 和 link。 park 命令在 Mac 系统中创建一个新目录，例如 mkdir ~/Sites，然后进入这个目录并运行 valet park。这个命令会将当前所在目录作为 Web 根目录。接下来，在新建的目录中创建一个新的 Laravel 站点： laravel new blog。接下来，在浏览器中访问 http://blog.com（我通过 valet domain com 将域名后缀改成了 .com）。￼ 这就是我们要做的全部工作。现在，所有在 Sites 目录中创建的 Laravel 项目都可以通过 http://folder-name.com 这种方式在浏览器中访问，是不是很方便？ link 命令link 命令也可以用于访问本地 Laravel 站点，当你想要提供单个访问站点时这个命令很有用。 要使用这个命令，先切换到你的某个项目并运行 valet link app-name，这样 Valet 会在 ~/.valet/Sites 中创建一个符号链接指向当前工作目录。运行完 link 命令后，可以在浏览器中通过 http://app-name.com 访问站点。要查看所有的链接目录，可以运行 valet links 命令。你也可以通过 valet unlink app-name 来删除符号链接。 你还可以使用 valet link 将多个（子）域名指向同一个应用，要添加子域名或其它域名到应用，可以在应用目录下运行 valet link subdomain.app-name，如这里我们在一个新应用下运行 valet link forum.blog： ￼ 一般来说我们使用 park 命令更方便一些，省去了后面新建应用重复执行命令，但是如果有子域名这类特殊需求，只能使用 link 命令来实现了。 通过TLS让站点更安全默认情况下，Valet 使用 HTTP 协议，如果你想要使用 HTTP/2 通过加密的 TLS 为站点提供服务，可以使用 secure 命令。例如，如果你的站点域名是 blog.com，可以使用如下命令： 1valet secure blog 要想回到”非安全”的 HTTP，可以使用 unsecure 命令。和 secure 命令一样，该命令接收主机名作为参数： 1valet unsecure blog 分享站点Valet 还提供了一个命令用于将本地站点共享给其他人，这不需要任何额外工具即可实现，和 Homestead 一样，底层也是通过 Ngrok 实现。 要共享站点，切换到站点所在目录并运行 valet share，这会生成一个可以公开访问的 URL 并插入剪贴板，以便你直接复制到浏览器地址栏，就是这么简单： ￼ 你可以通过 http://4c59137d.ngrok.io 或 https://4c59137d.ngrok.io 从任意联网机器访问站点（因为已经公开到互联网上）： ￼ 要停止共享站点，使用 Control + C 快捷键结束该命令即可。 valet share 目前尚不支持分享使用 valet secure 命令进行安全处理的站点，所以需要先通过 valet unsecrue 命令解除安全访问。 自定义 Valet 驱动你还可以编写自定义的 Valet 驱动为非 Valet 原生支持的 PHP 应用提供服务。安装完 Valet 时系统会创建一个 ~/.valet/Drivers 目录，该目录中有一个 SampleValetDriver.php 文件，这个文件中有一个演示如何编写自定义驱动的示例。编写一个驱动只需要实现三个方法：serves、isStaticFile 和frontControllerPath。 这三个方法接收 $sitePath、$siteName 和 $uri 值作为参数，其中 $sitePath 表示站点目录，如 ~/Sites/my-project，$siteName 表示主域名部分，如 my-project，而 $uri 则是输入的请求地址，如 /foo/bar。 编写好自定义的 Valet 驱动后，将其放到 ~/.valet/Drivers 目录并遵循 FrameworkValetDriver.php 这种命名方式，举个例子，如果你是在为 WordPress 编写自定义的 Valet 驱动，对应的文件名称为 WordPressValetDriver.php。 下面我们来具体讨论并演示自定义 Valet 驱动需要实现的三个方法。 serves 方法如果自定义驱动需要继续处理输入请求，serves 方法会返回true，否则该方法返回 false。因此，在这个方法中应该判断给定的 $sitePath 是否包含你服务类型的项目。 例如，假设我们编写的是 WordPressValetDriver，那么对应 serves 方法如下： 12345678910111213/** * Determine if the driver serves the request. * * @param string $sitePath * @param string $siteName * @param string $uri * @return void * @translator laravelacademy.org */public function serves($sitePath, $siteName, $uri)&#123; return is_dir($sitePath.&apos;/wp-admin&apos;);&#125; isStaticFile 方法isStaticFile 方法会判断输入请求是否是静态文件，例如图片或样式文件，如果文件是静态的，该方法会返回磁盘上的完整路径，如果输入请求不是请求静态文件，则返回 false： 1234567891011121314151617/** * Determine if the incoming request is for a static file. * * @param string $sitePath * @param string $siteName * @param string $uri * @return string|false */public function isStaticFile($sitePath, $siteName, $uri)&#123; if (file_exists($staticFilePath = $sitePath.&apos;/public/&apos;.$uri)) &#123; return $staticFilePath; &#125; return false;&#125;注：isStaticFile 方法只有在 serves 方法返回 true 并且请求 URI 不是 / 的时候才会被调用。 frontControllerPath 方法frontControllerPath 方法会返回前端控制器的完整路径，通常是 index.php： 123456789101112/** * Get the fully resolved path to the application&apos;s front controller. * * @param string $sitePath * @param string $siteName * @param string $uri * @return string */public function frontControllerPath($sitePath, $siteName, $uri)&#123; return $sitePath.&apos;/public/index.php&apos;;&#125; 关于自定义 Valet 驱动可以参考学院君为 Flarum 论坛编写的扩展教程：在 Mac 开发环境 Laravel Valet 中配置运行 Flarum 论坛系统。 本地驱动如果你想要为单应用程序定义一个自定义的 Valet 驱动，在应用根目录下创建一个 LocalValetDriver.php 文件，自定义驱动类可以继承自 ValetDriver 基类或者继承自已存在的应用指定驱动类如 LaravelValetDriver： 12345678910111213141516171819202122232425262728class LocalValetDriver extends LaravelValetDriver&#123; /** * Determine if the driver serves the request. * * @param string $sitePath * @param string $siteName * @param string $uri * @return bool */ public function serves($sitePath, $siteName, $uri) &#123; return true; &#125; /** * Get the fully resolved path to the application&apos;s front controller. * * @param string $sitePath * @param string $siteName * @param string $uri * @return string */ public function frontControllerPath($sitePath, $siteName, $uri) &#123; return $sitePath.&apos;/public_html/index.php&apos;; &#125;&#125; 其他常用 Valet 命令 命令 描述 valet forget 从”parked”目录运行该命令以便从 parked 目录列表中移除该目录 valet paths 查看你的”parked”路径 valet restart 重启 Valet valet start 启动 Valet valet stop 关闭 Valet valet uninstall 卸载 Valet","path":"2018/08/25/laravel-Valet安装使用教程/","date":"08-25","excerpt":""},{"title":"php如何实现保存网络图片","text":"123456789101112131415161718function file_exists_S3($url) &#123; $state = @file_get_contents($url,0,null,0,1);//获取网络资源的字符内容 if($state)&#123; $filename = date(&quot;dMYHis&quot;).&apos;.jpg&apos;;//文件名称生成 ob_start();//打开输出 readfile($url);//输出图片文件 $img = ob_get_contents();//得到浏览器输出 ob_end_clean();//清除输出并关闭 $size = strlen($img);//得到图片大小 $fp2 = @fopen($filename, &quot;a&quot;); fwrite($fp2, $img);//向当前目录写入图片文件，并重新命名 fclose($fp2); return 1; &#125; else&#123; return 0; &#125; &#125;注意：$filename可以改写成自己需要的路径","path":"2018/08/24/保存网络图片/","date":"08-24","excerpt":""},{"title":"php中常用的冒泡排序&快速排序算法以及二分查找&顺序查找的算法实现","text":"一、冒泡排序基本思想： 对需要排序的数组从后往前（逆序）进行多遍的扫描，当发现相邻的两个数值的次序与排序要求的规则不一致时，就将这两个数值进行交换。这样比较小（大）的数值就将逐渐从后面向前面移动。123456789101112131415161718192021&lt;?php function mysort($arr) &#123; for($i = 0; $i &lt; count($arr); $i++) &#123; $isSort = false; for ($j=0; $j&lt; count($arr) - $i - 1; $j++) &#123; if($arr[$j] &lt; $arr[$j+1]) &#123; $isSort = true; $temp = $arr[$j]; $arr[$j] = $arr[$j+1]; $arr[$j+1] = $temp ; &#125; &#125; if($isSort)&#123; break; &#125; &#125; return $arr; &#125; $arr = array(3,1,2); var_dump(mysort($arr));?&gt; 二、快速排序基本思想： 在数组中挑出一个元素（多为第一个）作为标尺，扫描一遍数组将比标尺小的元素排在标尺之前，将所有比标尺大的元素排在标尺之后，通过递归将各子序列分别划分为更小的序列直到所有的序列顺序一致。12345678910111213141516171819202122232425262728293031&lt;?php //快速排序 function quick_sort($arr) &#123; //先判断是否需要继续进行 $length = count($arr); if($length &lt;= 1) &#123; return $arr; &#125; $base_num = $arr[0];//选择一个标尺 选择第一个元素 //初始化两个数组 $left_array = array();//小于标尺的 $right_array = array();//大于标尺的 for($i=1; $i&lt;$length; $i++) &#123; //遍历 除了标尺外的所有元素，按照大小关系放入两个数组内 if($base_num &gt; $arr[$i]) &#123; //放入左边数组 $left_array[] = $arr[$i]; &#125; else&#123; //放入右边 $right_array[] = $arr[$i]; &#125; &#125; //再分别对 左边 和 右边的数组进行相同的排序处理方式 //递归调用这个函数,并记录结果 $left_array = quick_sort($left_array); $right_array = quick_sort($right_array); //合并左边 标尺 右边 return array_merge($left_array, array($base_num), $right_array); &#125; $arr = array(3,1,2); var_dump(quick_sort($arr));?&gt; 三、二分查找基本思想： 假设数据是按升序排序的，对于给定值x，从序列的中间位置开始比较，如果当前位置值等于x，则查找成功；若x小于当前位置值，则在数列的前半段中查找；若x大于当前位置值则在数列的后半段中继续查找，直到找到为止。（数据量大的时候使用）123456789101112131415161718&lt;?php //二分查找 function bin_search($arr,$low,$high,$k) &#123; if($low &lt;= $high) &#123; $mid = intval(($low + $high)/2); if($arr[$mid] == $k) &#123; return $mid; &#125;elseif ($k &lt; $arr[$mid])&#123; return bin_search($arr,$low,$mid-1,$k); &#125;else&#123; return bin_search($arr,$mid+1,$high,$k); &#125; &#125; return -1; &#125; $arr = array(1,2,3,4,5,6,7,8,9,10); print(bin_search($arr,0,9,3));?&gt; 四、顺序查找基本思想： 从数组的第一个元素开始一个一个向下查找，如果有和目标一致的元素，查找成功；如果到最后一个元素仍没有目标元素，则查找失败。12345678910111213141516&lt;?php //顺序查找 function seq_search($arr,$n,$k) &#123; $array[$n] = $k; for($i = 0;$i &lt; $n; $i++) &#123; if($arr[$i] == $k) &#123; break; &#125; if($i &lt; $n) &#123; return $i; &#125;else&#123; return -1; &#125; &#125; &#125; ?&gt; 五、写一个函数，能够遍历一个文件下的所有文件和子文件夹12345678910111213141516171819&lt;?php function my_scandir($dir) &#123; $files = array(); if($handle = opendir($dir)) &#123; while (($file = readdir($handle))!== false) &#123; if($file != &apos;..&apos; &amp;&amp; $file != &apos;.&apos;) &#123; if(is_dir($dir.&quot;/&quot;.$file))&#123; $files[$file]=my_scandir($dir.&quot;/&quot;.$file); &#125;else&#123; $files[] = $file; &#125; &#125; &#125; closedir($handle); return $files; &#125; &#125; var_dump(my_scandir(&apos;../&apos;));?&gt; 六、写一个函数，尽可能高效的从一个标准url中取出文件的扩展名12345678910111213&lt;?php function getExt($url )&#123; $arr = parse_url($url);//parse_url解析一个 URL 并返回一个关联数组，包含在 URL 中出现的各种组成部分 //&apos;scheme&apos; =&gt; string &apos;http&apos; (length=4) //&apos;host&apos; =&gt; string &apos;www.sina.com.cn&apos; (length=15) //&apos;path&apos; =&gt; string &apos;/abc/de/fg.php&apos; (length=14) //&apos;query&apos; =&gt; string &apos;id=1&apos; (length=4) $file = basename($arr[&apos;path&apos;]);// basename函数返回路径中的文件名部分 $ext = explode(&apos;.&apos;, $file); return $ext[count($ext)-1]; &#125; print(getExt(&apos;http://www.sina.com.cn/abc/de/fg.html.php?id=1&apos;));?&gt; 七、实现中文字符串截取无乱码的方法 可使用mb_substr,但是需要确保在php.ini中加载了php_mbstring.dll，即确保“extension=php_mbstring.dll”这一行存在并且没有被注释掉，否则会出现未定义函 数的问题。","path":"2018/08/24/冒泡排序/","date":"08-24","excerpt":""},{"title":"php实现无限极分类的方法：递归方法和引用方法","text":"递归算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325 /** * 递归实现无限极分类 * @param $array 分类数据 * @param $pid 父ID * @param $level 分类级别 * @return $list 分好类的数组 直接遍历即可 $level可以用来遍历缩进 */ function getTree($array, $pid =0, $level = 0)&#123; //声明静态数组,避免递归调用时,多次声明导致数组覆盖 static $list = []; foreach ($array as $key =&gt; $value)&#123; //第一次遍历,找到父节点为根节点的节点 也就是pid=0的节点 if ($value[&apos;pid&apos;] == $pid)&#123; //父节点为根节点的节点,级别为0，也就是第一级 $value[&apos;level&apos;] = $level; //把数组放到list中 $list[] = $value; //把这个节点从数组中移除,减少后续递归消耗 unset($array[$key]); //开始递归,查找父ID为该节点ID的节点,级别则为原级别+1 getTree($array, $value[&apos;id&apos;], $level+1); &#125; &#125; return $list; &#125; /* * 获得递归完的数据,遍历生成分类 */ $array = getTree($array); foreach($array) as $value&#123; echo str_repeat(&apos;--&apos;, $value[&apos;level&apos;]), $value[&apos;name&apos;].&apos;&lt;br /&gt;&apos;; &#125; //输出结果 无限极分类实现ok河北省--邯郸市----永年区--武安市北京市--朝阳区----望京----酒仙桥--通州区引用算法function generateTree($array)&#123; //第一步 构造数据 $items = array(); foreach($array as $value)&#123; $items[$value[&apos;id&apos;]] = $value; &#125; //第二部 遍历数据 生成树状结构 $tree = array(); foreach($items as $key =&gt; $value)&#123; if(isset($items[$item[&apos;pid&apos;]]))&#123; $items[$item[&apos;pid&apos;]][&apos;son&apos;][] = &amp;$items[$key]; &#125;else&#123; $tree[] = &amp;$items[$key]; &#125; &#125; return $tree;&#125; //经过第一步 数据变成了这样Array( [1] =&gt; Array ( [id] =&gt; 1 [pid] =&gt; 0 [name] =&gt; 河北省 [children] =&gt; Array ( ) ) [2] =&gt; Array ( [id] =&gt; 2 [pid] =&gt; 0 [name] =&gt; 北京市 [children] =&gt; Array ( ) ) [3] =&gt; Array ( [id] =&gt; 3 [pid] =&gt; 1 [name] =&gt; 邯郸市 [children] =&gt; Array ( ) ) [4] =&gt; Array ( [id] =&gt; 4 [pid] =&gt; 2 [name] =&gt; 朝阳区 [children] =&gt; Array ( ) ) [5] =&gt; Array ( [id] =&gt; 5 [pid] =&gt; 2 [name] =&gt; 通州区 [children] =&gt; Array ( ) ) [6] =&gt; Array ( [id] =&gt; 6 [pid] =&gt; 4 [name] =&gt; 望京 [children] =&gt; Array ( ) ) [7] =&gt; Array ( [id] =&gt; 7 [pid] =&gt; 4 [name] =&gt; 酒仙桥 [children] =&gt; Array ( ) ) [8] =&gt; Array ( [id] =&gt; 8 [pid] =&gt; 3 [name] =&gt; 永年区 [children] =&gt; Array ( ) ) [9] =&gt; Array ( [id] =&gt; 9 [pid] =&gt; 1 [name] =&gt; 武安市 [children] =&gt; Array ( ) ) ) //第一步很容易就能看懂，就是构造数据，现在咱们仔细说一下第二步 $tree = array(); //遍历构造的数据 foreach($items as $key =&gt; $value)&#123; //如果pid这个节点存在 if(isset($items[$value[&apos;pid&apos;]]))&#123; //把当前的$value放到pid节点的son中 注意 这里传递的是引用 为什么呢？ $items[$value[&apos;pid&apos;]][&apos;son&apos;][] = &amp;$items[$key]; &#125;else&#123; $tree[] = &amp;$items[$key]; &#125; &#125; //这个方法的核心在于引用，php变量默认的传值方式是按指传递//也就是说 假如说 遍历顺序是 河北省 邯郸市 当遍历到河北省时 会把河北省放到tree中 遍历到邯郸市时 会把邯郸市放到河北省的子节点数组中 但是！！！ 这会儿的tree数组中 河北省已经放进去了 根据php变量按值传递的规则 你并没有更改tree数组中的河北省的数据 所以这里用到了引用传递//当你对河北省做更改时，tree数组中的河北省也一并做了更改 下面我们做个实验 我们把引用传递去掉，看一下结果 //使用普通传值输出结果 Array( [0] =&gt; Array ( [id] =&gt; 1 [pid] =&gt; 0 [name] =&gt; 河北省 ) [1] =&gt; Array ( [id] =&gt; 2 [pid] =&gt; 0 [name] =&gt; 北京市 ) )//可以看到 只有河北省和北京市输出出来了 因为他们俩是第一级节点 而且排行1和2，放到$tree数组中之后，没有使用引用传递，那么后续对他俩的子节点的操作都没有在$tree中生效，现在我们更改一下顺序 把邯郸市放到河北省的前面 那么根据咱们的推断 那么邯郸市就应该出现在tree数组里 //邯郸市放到河北省前面的输出结果Array( [0] =&gt; Array ( [id] =&gt; 1 [pid] =&gt; 0 [name] =&gt; 河北省 [son] =&gt; Array ( [0] =&gt; Array ( [id] =&gt; 3 [pid] =&gt; 1 [name] =&gt; 邯郸市 ) ) ) [1] =&gt; Array ( [id] =&gt; 2 [pid] =&gt; 0 [name] =&gt; 北京市 ) ) //果然是这样 那么证明我们的推断是正确的 现在我们把引用传值改回去 再看一下 //使用引用传值输出结果Array( [1] =&gt; Array ( [id] =&gt; 1 [pid] =&gt; 0 [name] =&gt; 河北省 [children] =&gt; Array ( [0] =&gt; Array ( [id] =&gt; 3 [pid] =&gt; 1 [name] =&gt; 邯郸市 [children] =&gt; Array ( [0] =&gt; Array ( [id] =&gt; 8 [pid] =&gt; 3 [name] =&gt; 永年区 ) ) ) [1] =&gt; Array ( [id] =&gt; 9 [pid] =&gt; 1 [name] =&gt; 武安市 ) ) ) [2] =&gt; Array ( [id] =&gt; 2 [pid] =&gt; 0 [name] =&gt; 北京市 [children] =&gt; Array ( [0] =&gt; Array ( [id] =&gt; 4 [pid] =&gt; 2 [name] =&gt; 朝阳区 [children] =&gt; Array ( [0] =&gt; Array ( [id] =&gt; 6 [pid] =&gt; 4 [name] =&gt; 望京 ) [1] =&gt; Array ( [id] =&gt; 7 [pid] =&gt; 4 [name] =&gt; 酒仙桥 ) ) ) [1] =&gt; Array ( [id] =&gt; 5 [pid] =&gt; 2 [name] =&gt; 通州区 ) ) ) )//树状结构完美的输出出来了 这个方法的核心就是引用传值","path":"2018/08/24/递归方法/","date":"08-24","excerpt":""},{"title":"搭建hexo","text":"HEXO一个快速，简单和强大的博客框架，由Node.js提供支持。 特征 快速生成 支持GitHub Flavored Markdown和大多数Octopress插件 单命令部署到GitHub页面，Heroku等。 强大的插件系统 安装 $ npm install hexo-cli -g 快速开始设置您的博客 $ hexo init blog $ cd blog 启动服务器 $ hexo server 创建一个新帖子 $ hexo new “ Hello Hexo ” 生成静态文件 $ hexo generate","path":"2018/08/07/搭建hexo/","date":"08-07","excerpt":""},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2018/08/07/hello-world/","date":"08-07","excerpt":""}]}